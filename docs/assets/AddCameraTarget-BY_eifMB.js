import{n as zr,q as Gr,r as b,t as kr,v as Vr,g as Vn,a as Wn,d as Zn,u as $n,j as Ie,e as jn,f as Xn,w as Wr,c as Zr,_ as Yn,R as Pt,B as $r,T as jr,s as Xr}from"./index-CkEUT0eu.js";import{ak as Yr,u as et,g as pn,$ as ft,m as Qe,O as mn,a3 as vn,V as Ae,al as Wt,M as Nt,am as Kr,S as tt,an as Kn,ao as Qn,H as Pe,F as $e,ap as pt,L as be,aa as Dt,k as Qr,aq as st,d as Yt,P as qn,W as Ge,ar as Kt,as as qr,a8 as Jr,at as Bt,K as ot,au as ei,av as ti,aw as ni,ax as Jn,ay as ct,i as er,az as Xt,aA as ri,aB as ii,aC as Pn,aD as Ze,aE as gt,aF as Qt,aG as ai,aH as si,aI as oi,aJ as li,f as ci,h as tr,ab as Dn,D as ui,aK as di,aL as hi,aM as gn,a9 as nr,aN as Et,N as vt,aO as fi,C as rr,aP as pi,aQ as Zt,aR as mi,aS as ae,aT as ir,j as vi,R as En,a6 as gi,a7 as Bn,aU as Ei,ai as Si,l as xi,G as _i,e as wi,ag as Mi}from"./HamburgerMenu-BCXgWqBx.js";function yi(e){const{theme:t,name:n,props:a}=e;return!t||!t.components||!t.components[n]||!t.components[n].defaultProps?a:zr(t.components[n].defaultProps,a)}function Ti(e,t,n,a,s){const[o,c]=b.useState(()=>s&&n?n(e).matches:a?a(e).matches:t);return kr(()=>{if(!n)return;const u=n(e),d=()=>{c(u.matches)};return d(),u.addEventListener("change",d),()=>{u.removeEventListener("change",d)}},[e,n]),o}const bi={...Vr},ar=bi.useSyncExternalStore;function Ri(e,t,n,a,s){const o=b.useCallback(()=>t,[t]),c=b.useMemo(()=>{if(s&&n)return()=>n(e).matches;if(a!==null){const{matches:v}=a(e);return()=>v}return o},[o,e,a,s,n]),[u,d]=b.useMemo(()=>{if(n===null)return[o,()=>()=>{}];const v=n(e);return[()=>v.matches,g=>(v.addEventListener("change",g),()=>{v.removeEventListener("change",g)})]},[o,n,e]);return ar(d,u,c)}function Ci(e={}){const{themeId:t}=e;return function(a,s={}){let o=Gr();o&&t&&(o=o[t]||o);const c=typeof window<"u"&&typeof window.matchMedia<"u",{defaultMatches:u=!1,matchMedia:d=c?window.matchMedia:null,ssrMatchMedia:m=null,noSsr:v=!1}=yi({name:"MuiUseMediaQuery",props:s,theme:o});let g=typeof a=="function"?a(o):a;return g=g.replace(/^@media( ?)/m,""),(ar!==void 0?Ri:Ti)(g,u,d,m,v)}}function Ai(e){return Wn("MuiCard",e)}Vn("MuiCard",["root"]);const Ii=e=>{const{classes:t}=e;return Xn({root:["root"]},Ai,t)},Pi=Zn(Yr,{name:"MuiCard",slot:"Root",overridesResolver:(e,t)=>t.root})({overflow:"hidden"}),Ws=b.forwardRef(function(t,n){const a=$n({props:t,name:"MuiCard"}),{className:s,raised:o=!1,...c}=a,u={...a,raised:o},d=Ii(u);return Ie.jsx(Pi,{className:jn(d.root,s),elevation:o?8:void 0,ref:n,ownerState:u,...c})});function Di(e){return Wn("MuiCardContent",e)}Vn("MuiCardContent",["root"]);const Bi=e=>{const{classes:t}=e;return Xn({root:["root"]},Di,t)},Li=Zn("div",{name:"MuiCardContent",slot:"Root",overridesResolver:(e,t)=>t.root})({padding:16,"&:last-child":{paddingBottom:24}}),Zs=b.forwardRef(function(t,n){const a=$n({props:t,name:"MuiCardContent"}),{className:s,component:o="div",...c}=a,u={...a,component:o},d=Bi(u);return Ie.jsx(Li,{as:o,className:jn(d.root,s),ownerState:u,ref:n,...c})}),$s=Ci({themeId:Wr}),Ot=new Qe,Sn=new Qe,Ni=new Qe,Ln=new Ae;function Oi(e,t,n){const a=Ot.setFromMatrixPosition(e.matrixWorld);a.project(t);const s=n.width/2,o=n.height/2;return[a.x*s+s,-(a.y*o)+o]}function Fi(e,t){const n=Ot.setFromMatrixPosition(e.matrixWorld),a=Sn.setFromMatrixPosition(t.matrixWorld),s=n.sub(a),o=t.getWorldDirection(Ni);return s.angleTo(o)>Math.PI/2}function Ui(e,t,n,a){const s=Ot.setFromMatrixPosition(e.matrixWorld),o=s.clone();o.project(t),Ln.set(o.x,o.y),n.setFromCamera(Ln,t);const c=n.intersectObjects(a,!0);if(c.length){const u=c[0].distance;return s.distanceTo(n.ray.origin)<u}return!0}function Hi(e,t){if(t instanceof mn)return t.zoom;if(t instanceof vn){const n=Ot.setFromMatrixPosition(e.matrixWorld),a=Sn.setFromMatrixPosition(t.matrixWorld),s=t.fov*Math.PI/180,o=n.distanceTo(a);return 1/(2*Math.tan(s/2)*o)}else return 1}function zi(e,t,n){if(t instanceof vn||t instanceof mn){const a=Ot.setFromMatrixPosition(e.matrixWorld),s=Sn.setFromMatrixPosition(t.matrixWorld),o=a.distanceTo(s),c=(n[1]-n[0])/(t.far-t.near),u=n[1]-c*t.far;return Math.round(c*o+u)}}const cn=e=>Math.abs(e)<1e-10?0:e;function sr(e,t,n=""){let a="matrix3d(";for(let s=0;s!==16;s++)a+=cn(t[s]*e.elements[s])+(s!==15?",":")");return n+a}const Gi=(e=>t=>sr(t,e))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),ki=(e=>(t,n)=>sr(t,e(n),"translate(-50%,-50%)"))(e=>[1/e,1/e,1/e,1,-1/e,-1/e,-1/e,-1,1/e,1/e,1/e,1,1,1,1,1]);function Vi(e){return e&&typeof e=="object"&&"current"in e}const Wi=b.forwardRef(({children:e,eps:t=.001,style:n,className:a,prepend:s,center:o,fullscreen:c,portal:u,distanceFactor:d,sprite:m=!1,transform:v=!1,occlude:g,onOcclude:R,castShadow:I,receiveShadow:Z,material:Y,geometry:H,zIndexRange:k=[16777271,0],calculatePosition:L=Oi,as:D="div",wrapperClass:K,pointerEvents:V="auto",...O},ne)=>{const{gl:_,camera:S,scene:U,size:P,raycaster:z,events:$,viewport:N}=et(),[W]=b.useState(()=>document.createElement(D)),F=b.useRef(),fe=b.useRef(null),ke=b.useRef(0),Ee=b.useRef([0,0]),J=b.useRef(null),Be=b.useRef(null),ee=(u==null?void 0:u.current)||$.connected||_.domElement.parentNode,le=b.useRef(null),we=b.useRef(!1),Ve=b.useMemo(()=>g&&g!=="blending"||Array.isArray(g)&&g.length&&Vi(g[0]),[g]);b.useLayoutEffect(()=>{const Me=_.domElement;g&&g==="blending"?(Me.style.zIndex=`${Math.floor(k[0]/2)}`,Me.style.position="absolute",Me.style.pointerEvents="none"):(Me.style.zIndex=null,Me.style.position=null,Me.style.pointerEvents=null)},[g]),b.useLayoutEffect(()=>{if(fe.current){const Me=F.current=Zr.createRoot(W);if(U.updateMatrixWorld(),v)W.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const ie=L(fe.current,S,P);W.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${ie[0]}px,${ie[1]}px,0);transform-origin:0 0;`}return ee&&(s?ee.prepend(W):ee.appendChild(W)),()=>{ee&&ee.removeChild(W),Me.unmount()}}},[ee,v]),b.useLayoutEffect(()=>{K&&(W.className=K)},[K]);const te=b.useMemo(()=>v?{position:"absolute",top:0,left:0,width:P.width,height:P.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:o?"translate3d(-50%,-50%,0)":"none",...c&&{top:-P.height/2,left:-P.width/2,width:P.width,height:P.height},...n},[n,o,c,P,v]),He=b.useMemo(()=>({position:"absolute",pointerEvents:V}),[V]);b.useLayoutEffect(()=>{if(we.current=!1,v){var Me;(Me=F.current)==null||Me.render(b.createElement("div",{ref:J,style:te},b.createElement("div",{ref:Be,style:He},b.createElement("div",{ref:ne,className:a,style:n,children:e}))))}else{var ie;(ie=F.current)==null||ie.render(b.createElement("div",{ref:ne,style:te,className:a,children:e}))}});const Se=b.useRef(!0);pn(Me=>{if(fe.current){S.updateMatrixWorld(),fe.current.updateWorldMatrix(!0,!1);const ie=v?Ee.current:L(fe.current,S,P);if(v||Math.abs(ke.current-S.zoom)>t||Math.abs(Ee.current[0]-ie[0])>t||Math.abs(Ee.current[1]-ie[1])>t){const je=Fi(fe.current,S);let Le=!1;Ve&&(Array.isArray(g)?Le=g.map(Xe=>Xe.current):g!=="blending"&&(Le=[U]));const nt=Se.current;if(Le){const Xe=Ui(fe.current,S,z,Le);Se.current=Xe&&!je}else Se.current=!je;nt!==Se.current&&(R?R(!Se.current):W.style.display=Se.current?"block":"none");const ut=Math.floor(k[0]/2),Jt=g?Ve?[k[0],ut]:[ut-1,0]:k;if(W.style.zIndex=`${zi(fe.current,S,Jt)}`,v){const[Xe,Ht]=[P.width/2,P.height/2],St=S.projectionMatrix.elements[5]*Ht,{isOrthographicCamera:zt,top:en,left:tn,bottom:Gt,right:nn}=S,xt=Gi(S.matrixWorldInverse),rn=zt?`scale(${St})translate(${cn(-(nn+tn)/2)}px,${cn((en+Gt)/2)}px)`:`translateZ(${St}px)`;let Ye=fe.current.matrixWorld;m&&(Ye=S.matrixWorldInverse.clone().transpose().copyPosition(Ye).scale(fe.current.scale),Ye.elements[3]=Ye.elements[7]=Ye.elements[11]=0,Ye.elements[15]=1),W.style.width=P.width+"px",W.style.height=P.height+"px",W.style.perspective=zt?"":`${St}px`,J.current&&Be.current&&(J.current.style.transform=`${rn}${xt}translate(${Xe}px,${Ht}px)`,Be.current.style.transform=ki(Ye,1/((d||10)/400)))}else{const Xe=d===void 0?1:Hi(fe.current,S)*d;W.style.transform=`translate3d(${ie[0]}px,${ie[1]}px,0) scale(${Xe})`}Ee.current=ie,ke.current=S.zoom}}if(!Ve&&le.current&&!we.current)if(v){if(J.current){const ie=J.current.children[0];if(ie!=null&&ie.clientWidth&&ie!=null&&ie.clientHeight){const{isOrthographicCamera:je}=S;if(je||H)O.scale&&(Array.isArray(O.scale)?O.scale instanceof Qe?le.current.scale.copy(O.scale.clone().divideScalar(1)):le.current.scale.set(1/O.scale[0],1/O.scale[1],1/O.scale[2]):le.current.scale.setScalar(1/O.scale));else{const Le=(d||10)/400,nt=ie.clientWidth*Le,ut=ie.clientHeight*Le;le.current.scale.set(nt,ut,1)}we.current=!0}}}else{const ie=W.children[0];if(ie!=null&&ie.clientWidth&&ie!=null&&ie.clientHeight){const je=1/N.factor,Le=ie.clientWidth*je,nt=ie.clientHeight*je;le.current.scale.set(Le,nt,1),we.current=!0}le.current.lookAt(Me.camera.position)}});const Ut=b.useMemo(()=>({vertexShader:v?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[v]);return b.createElement("group",Yn({},O,{ref:fe}),g&&!Ve&&b.createElement("mesh",{castShadow:I,receiveShadow:Z,ref:le},H||b.createElement("planeGeometry",null),Y||b.createElement("shaderMaterial",{side:ft,vertexShader:Ut.vertexShader,fragmentShader:Ut.fragmentShader})))}),Nn=e=>{let t;const n=new Set,a=(m,v)=>{const g=typeof m=="function"?m(t):m;if(!Object.is(g,t)){const R=t;t=v??(typeof g!="object"||g===null)?g:Object.assign({},t,g),n.forEach(I=>I(t,R))}},s=()=>t,u={setState:a,getState:s,getInitialState:()=>d,subscribe:m=>(n.add(m),()=>n.delete(m))},d=t=e(a,s,u);return u},Zi=e=>e?Nn(e):Nn,$i=e=>e;function ji(e,t=$i){const n=Pt.useSyncExternalStore(e.subscribe,()=>t(e.getState()),()=>t(e.getInitialState()));return Pt.useDebugValue(n),n}const On=e=>{const t=Zi(e),n=a=>ji(t,a);return Object.assign(n,t),n},Xi=e=>e?On(e):On;let bt=0;const Yi=Xi(e=>(Wt.onStart=(t,n,a)=>{e({active:!0,item:t,loaded:n,total:a,progress:(n-bt)/(a-bt)*100})},Wt.onLoad=()=>{e({active:!1})},Wt.onError=t=>e(n=>({errors:[...n.errors,t]})),Wt.onProgress=(t,n,a)=>{n===a&&(bt=a),e({active:!0,item:t,loaded:n,total:a,progress:(n-bt)/(a-bt)*100||100})},{errors:[],active:!1,progress:0,item:"",loaded:0,total:0}));let Rt;function Ki(){var e;if(Rt!==void 0)return Rt;try{let t;const n=document.createElement("canvas");return Rt=!!(window.WebGL2RenderingContext&&(t=n.getContext("webgl2"))),t&&((e=t.getExtension("WEBGL_lose_context"))==null||e.loseContext()),Rt}catch{return Rt=!1}}var Ue=Uint8Array,lt=Uint16Array,un=Uint32Array,or=new Ue([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),lr=new Ue([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Qi=new Ue([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),cr=function(e,t){for(var n=new lt(31),a=0;a<31;++a)n[a]=t+=1<<e[a-1];for(var s=new un(n[30]),a=1;a<30;++a)for(var o=n[a];o<n[a+1];++o)s[o]=o-n[a]<<5|a;return[n,s]},ur=cr(or,2),dr=ur[0],qi=ur[1];dr[28]=258,qi[258]=28;var Ji=cr(lr,0),ea=Ji[0],dn=new lt(32768);for(var he=0;he<32768;++he){var it=(he&43690)>>>1|(he&21845)<<1;it=(it&52428)>>>2|(it&13107)<<2,it=(it&61680)>>>4|(it&3855)<<4,dn[he]=((it&65280)>>>8|(it&255)<<8)>>>1}var It=function(e,t,n){for(var a=e.length,s=0,o=new lt(t);s<a;++s)++o[e[s]-1];var c=new lt(t);for(s=0;s<t;++s)c[s]=c[s-1]+o[s-1]<<1;var u;if(n){u=new lt(1<<t);var d=15-t;for(s=0;s<a;++s)if(e[s])for(var m=s<<4|e[s],v=t-e[s],g=c[e[s]-1]++<<v,R=g|(1<<v)-1;g<=R;++g)u[dn[g]>>>d]=m}else for(u=new lt(a),s=0;s<a;++s)e[s]&&(u[s]=dn[c[e[s]-1]++]>>>15-e[s]);return u},Ft=new Ue(288);for(var he=0;he<144;++he)Ft[he]=8;for(var he=144;he<256;++he)Ft[he]=9;for(var he=256;he<280;++he)Ft[he]=7;for(var he=280;he<288;++he)Ft[he]=8;var hr=new Ue(32);for(var he=0;he<32;++he)hr[he]=5;var ta=It(Ft,9,1),na=It(hr,5,1),an=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},ze=function(e,t,n){var a=t/8|0;return(e[a]|e[a+1]<<8)>>(t&7)&n},sn=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(t&7)},ra=function(e){return(e/8|0)+(e&7&&1)},ia=function(e,t,n){(n==null||n>e.length)&&(n=e.length);var a=new(e instanceof lt?lt:e instanceof un?un:Ue)(n-t);return a.set(e.subarray(t,n)),a},aa=function(e,t,n){var a=e.length;if(!a||n&&!n.l&&a<5)return t||new Ue(0);var s=!t||n,o=!n||n.i;n||(n={}),t||(t=new Ue(a*3));var c=function(te){var He=t.length;if(te>He){var Se=new Ue(Math.max(He*2,te));Se.set(t),t=Se}},u=n.f||0,d=n.p||0,m=n.b||0,v=n.l,g=n.d,R=n.m,I=n.n,Z=a*8;do{if(!v){n.f=u=ze(e,d,1);var Y=ze(e,d+1,3);if(d+=3,Y)if(Y==1)v=ta,g=na,R=9,I=5;else if(Y==2){var D=ze(e,d,31)+257,K=ze(e,d+10,15)+4,V=D+ze(e,d+5,31)+1;d+=14;for(var O=new Ue(V),ne=new Ue(19),_=0;_<K;++_)ne[Qi[_]]=ze(e,d+_*3,7);d+=K*3;for(var S=an(ne),U=(1<<S)-1,P=It(ne,S,1),_=0;_<V;){var z=P[ze(e,d,U)];d+=z&15;var H=z>>>4;if(H<16)O[_++]=H;else{var $=0,N=0;for(H==16?(N=3+ze(e,d,3),d+=2,$=O[_-1]):H==17?(N=3+ze(e,d,7),d+=3):H==18&&(N=11+ze(e,d,127),d+=7);N--;)O[_++]=$}}var W=O.subarray(0,D),F=O.subarray(D);R=an(W),I=an(F),v=It(W,R,1),g=It(F,I,1)}else throw"invalid block type";else{var H=ra(d)+4,k=e[H-4]|e[H-3]<<8,L=H+k;if(L>a){if(o)throw"unexpected EOF";break}s&&c(m+k),t.set(e.subarray(H,L),m),n.b=m+=k,n.p=d=L*8;continue}if(d>Z){if(o)throw"unexpected EOF";break}}s&&c(m+131072);for(var fe=(1<<R)-1,ke=(1<<I)-1,Ee=d;;Ee=d){var $=v[sn(e,d)&fe],J=$>>>4;if(d+=$&15,d>Z){if(o)throw"unexpected EOF";break}if(!$)throw"invalid length/literal";if(J<256)t[m++]=J;else if(J==256){Ee=d,v=null;break}else{var Be=J-254;if(J>264){var _=J-257,ee=or[_];Be=ze(e,d,(1<<ee)-1)+dr[_],d+=ee}var le=g[sn(e,d)&ke],we=le>>>4;if(!le)throw"invalid distance";d+=le&15;var F=ea[we];if(we>3){var ee=lr[we];F+=sn(e,d)&(1<<ee)-1,d+=ee}if(d>Z){if(o)throw"unexpected EOF";break}s&&c(m+131072);for(var Ve=m+Be;m<Ve;m+=4)t[m]=t[m-F],t[m+1]=t[m+1-F],t[m+2]=t[m+2-F],t[m+3]=t[m+3-F];m=Ve}}n.l=v,n.p=Ee,n.b=m,v&&(u=1,n.m=R,n.d=g,n.n=I)}while(!u);return m==t.length?t:ia(t,0,m)},sa=new Ue(0),oa=function(e){if((e[0]&15)!=8||e[0]>>>4>7||(e[0]<<8|e[1])%31)throw"invalid zlib data";if(e[1]&32)throw"invalid zlib data: preset dictionaries not supported"};function $t(e,t){return aa((oa(e),e.subarray(2,-4)),t)}var la=typeof TextDecoder<"u"&&new TextDecoder,ca=0;try{la.decode(sa,{stream:!0}),ca=1}catch{}const ua=e=>e&&e.isCubeTexture;class da extends Nt{constructor(t,n){var a,s;const o=ua(t),u=((s=o?(a=t.image[0])==null?void 0:a.width:t.image.width)!=null?s:1024)/4,d=Math.floor(Math.log2(u)),m=Math.pow(2,d),v=3*Math.max(m,16*7),g=4*m,R=[o?"#define ENVMAP_TYPE_CUBE":"",`#define CUBEUV_TEXEL_WIDTH ${1/v}`,`#define CUBEUV_TEXEL_HEIGHT ${1/g}`,`#define CUBEUV_MAX_MIP ${d}.0`],I=`
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `,Z=R.join(`
`)+`
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${Kn>=154?"colorspace_fragment":"encodings_fragment"}>
        }
        `,Y={map:{value:t},height:{value:(n==null?void 0:n.height)||15},radius:{value:(n==null?void 0:n.radius)||100}},H=new Kr(1,16),k=new tt({uniforms:Y,fragmentShader:Z,vertexShader:I,side:ft});super(H,k)}set radius(t){this.material.uniforms.radius.value=t}get radius(){return this.material.uniforms.radius.value}set height(t){this.material.uniforms.height.value=t}get height(){return this.material.uniforms.height.value}}class ha extends Qn{constructor(t){super(t),this.type=Pe}parse(t){const c=function(_,S){switch(_){case 1:throw new Error("THREE.RGBELoader: Read Error: "+(S||""));case 2:throw new Error("THREE.RGBELoader: Write Error: "+(S||""));case 3:throw new Error("THREE.RGBELoader: Bad File Format: "+(S||""));default:case 4:throw new Error("THREE.RGBELoader: Memory Error: "+(S||""))}},v=`
`,g=function(_,S,U){S=S||1024;let z=_.pos,$=-1,N=0,W="",F=String.fromCharCode.apply(null,new Uint16Array(_.subarray(z,z+128)));for(;0>($=F.indexOf(v))&&N<S&&z<_.byteLength;)W+=F,N+=F.length,z+=128,F+=String.fromCharCode.apply(null,new Uint16Array(_.subarray(z,z+128)));return-1<$?(_.pos+=N+$+1,W+F.slice(0,$)):!1},R=function(_){const S=/^#\?(\S+)/,U=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,P=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,z=/^\s*FORMAT=(\S+)\s*$/,$=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,N={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let W,F;for((_.pos>=_.byteLength||!(W=g(_)))&&c(1,"no header found"),(F=W.match(S))||c(3,"bad initial token"),N.valid|=1,N.programtype=F[1],N.string+=W+`
`;W=g(_),W!==!1;){if(N.string+=W+`
`,W.charAt(0)==="#"){N.comments+=W+`
`;continue}if((F=W.match(U))&&(N.gamma=parseFloat(F[1])),(F=W.match(P))&&(N.exposure=parseFloat(F[1])),(F=W.match(z))&&(N.valid|=2,N.format=F[1]),(F=W.match($))&&(N.valid|=4,N.height=parseInt(F[1],10),N.width=parseInt(F[2],10)),N.valid&2&&N.valid&4)break}return N.valid&2||c(3,"missing format specifier"),N.valid&4||c(3,"missing image size specifier"),N},I=function(_,S,U){const P=S;if(P<8||P>32767||_[0]!==2||_[1]!==2||_[2]&128)return new Uint8Array(_);P!==(_[2]<<8|_[3])&&c(3,"wrong scanline width");const z=new Uint8Array(4*S*U);z.length||c(4,"unable to allocate buffer space");let $=0,N=0;const W=4*P,F=new Uint8Array(4),fe=new Uint8Array(W);let ke=U;for(;ke>0&&N<_.byteLength;){N+4>_.byteLength&&c(1),F[0]=_[N++],F[1]=_[N++],F[2]=_[N++],F[3]=_[N++],(F[0]!=2||F[1]!=2||(F[2]<<8|F[3])!=P)&&c(3,"bad rgbe scanline format");let Ee=0,J;for(;Ee<W&&N<_.byteLength;){J=_[N++];const ee=J>128;if(ee&&(J-=128),(J===0||Ee+J>W)&&c(3,"bad scanline data"),ee){const le=_[N++];for(let we=0;we<J;we++)fe[Ee++]=le}else fe.set(_.subarray(N,N+J),Ee),Ee+=J,N+=J}const Be=P;for(let ee=0;ee<Be;ee++){let le=0;z[$]=fe[ee+le],le+=P,z[$+1]=fe[ee+le],le+=P,z[$+2]=fe[ee+le],le+=P,z[$+3]=fe[ee+le],$+=4}ke--}return z},Z=function(_,S,U,P){const z=_[S+3],$=Math.pow(2,z-128)/255;U[P+0]=_[S+0]*$,U[P+1]=_[S+1]*$,U[P+2]=_[S+2]*$,U[P+3]=1},Y=function(_,S,U,P){const z=_[S+3],$=Math.pow(2,z-128)/255;U[P+0]=pt.toHalfFloat(Math.min(_[S+0]*$,65504)),U[P+1]=pt.toHalfFloat(Math.min(_[S+1]*$,65504)),U[P+2]=pt.toHalfFloat(Math.min(_[S+2]*$,65504)),U[P+3]=pt.toHalfFloat(1)},H=new Uint8Array(t);H.pos=0;const k=R(H),L=k.width,D=k.height,K=I(H.subarray(H.pos),L,D);let V,O,ne;switch(this.type){case $e:ne=K.length/4;const _=new Float32Array(ne*4);for(let U=0;U<ne;U++)Z(K,U*4,_,U*4);V=_,O=$e;break;case Pe:ne=K.length/4;const S=new Uint16Array(ne*4);for(let U=0;U<ne;U++)Y(K,U*4,S,U*4);V=S,O=Pe;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+this.type)}return{width:L,height:D,data:V,header:k.string,gamma:k.gamma,exposure:k.exposure,type:O}}setDataType(t){return this.type=t,this}load(t,n,a,s){function o(c,u){switch(c.type){case $e:case Pe:"colorSpace"in c?c.colorSpace="srgb-linear":c.encoding=3e3,c.minFilter=be,c.magFilter=be,c.generateMipmaps=!1,c.flipY=!0;break}n&&n(c,u)}return super.load(t,o,a,s)}}const Ct=Kn>=152;class fa extends Qn{constructor(t){super(t),this.type=Pe}parse(t){const S=Math.pow(2.7182818,2.2);function U(r,i){for(var l=0,h=0;h<65536;++h)(h==0||r[h>>3]&1<<(h&7))&&(i[l++]=h);for(var f=l-1;l<65536;)i[l++]=0;return f}function P(r){for(var i=0;i<16384;i++)r[i]={},r[i].len=0,r[i].lit=0,r[i].p=null}const z={l:0,c:0,lc:0};function $(r,i,l,h,f){for(;l<r;)i=i<<8|An(h,f),l+=8;l-=r,z.l=i>>l&(1<<r)-1,z.c=i,z.lc=l}const N=new Array(59);function W(r){for(var i=0;i<=58;++i)N[i]=0;for(var i=0;i<65537;++i)N[r[i]]+=1;for(var l=0,i=58;i>0;--i){var h=l+N[i]>>1;N[i]=l,l=h}for(var i=0;i<65537;++i){var f=r[i];f>0&&(r[i]=f|N[f]++<<6)}}function F(r,i,l,h,f,p,x){for(var E=l,y=0,M=0;f<=p;f++){if(E.value-l.value>h)return!1;$(6,y,M,r,E);var T=z.l;if(y=z.c,M=z.lc,x[f]=T,T==63){if(E.value-l.value>h)throw"Something wrong with hufUnpackEncTable";$(8,y,M,r,E);var w=z.l+6;if(y=z.c,M=z.lc,f+w>p+1)throw"Something wrong with hufUnpackEncTable";for(;w--;)x[f++]=0;f--}else if(T>=59){var w=T-59+2;if(f+w>p+1)throw"Something wrong with hufUnpackEncTable";for(;w--;)x[f++]=0;f--}}W(x)}function fe(r){return r&63}function ke(r){return r>>6}function Ee(r,i,l,h){for(;i<=l;i++){var f=ke(r[i]),p=fe(r[i]);if(f>>p)throw"Invalid table entry";if(p>14){var x=h[f>>p-14];if(x.len)throw"Invalid table entry";if(x.lit++,x.p){var E=x.p;x.p=new Array(x.lit);for(var y=0;y<x.lit-1;++y)x.p[y]=E[y]}else x.p=new Array(1);x.p[x.lit-1]=i}else if(p)for(var M=0,y=1<<14-p;y>0;y--){var x=h[(f<<14-p)+M];if(x.len||x.p)throw"Invalid table entry";x.len=p,x.lit=i,M++}}return!0}const J={c:0,lc:0};function Be(r,i,l,h){r=r<<8|An(l,h),i+=8,J.c=r,J.lc=i}const ee={c:0,lc:0};function le(r,i,l,h,f,p,x,E,y,M){if(r==i){h<8&&(Be(l,h,f,x),l=J.c,h=J.lc),h-=8;var T=l>>h,T=new Uint8Array([T])[0];if(y.value+T>M)return!1;for(var w=E[y.value-1];T-- >0;)E[y.value++]=w}else if(y.value<M)E[y.value++]=r;else return!1;ee.c=l,ee.lc=h}function we(r){return r&65535}function Ve(r){var i=we(r);return i>32767?i-65536:i}const te={a:0,b:0};function He(r,i){var l=Ve(r),h=Ve(i),f=h,p=l+(f&1)+(f>>1),x=p,E=p-f;te.a=x,te.b=E}function Se(r,i){var l=we(r),h=we(i),f=l-(h>>1)&65535,p=h+f-32768&65535;te.a=p,te.b=f}function Ut(r,i,l,h,f,p,x){for(var E=x<16384,y=l>f?f:l,M=1,T;M<=y;)M<<=1;for(M>>=1,T=M,M>>=1;M>=1;){for(var w=0,me=w+p*(f-T),A=p*M,B=p*T,G=h*M,j=h*T,se,ce,ve,ye;w<=me;w+=B){for(var ue=w,We=w+h*(l-T);ue<=We;ue+=j){var de=ue+G,ge=ue+A,Ke=ge+G;E?(He(r[ue+i],r[ge+i]),se=te.a,ve=te.b,He(r[de+i],r[Ke+i]),ce=te.a,ye=te.b,He(se,ce),r[ue+i]=te.a,r[de+i]=te.b,He(ve,ye),r[ge+i]=te.a,r[Ke+i]=te.b):(Se(r[ue+i],r[ge+i]),se=te.a,ve=te.b,Se(r[de+i],r[Ke+i]),ce=te.a,ye=te.b,Se(se,ce),r[ue+i]=te.a,r[de+i]=te.b,Se(ve,ye),r[ge+i]=te.a,r[Ke+i]=te.b)}if(l&M){var ge=ue+A;E?He(r[ue+i],r[ge+i]):Se(r[ue+i],r[ge+i]),se=te.a,r[ge+i]=te.b,r[ue+i]=se}}if(f&M)for(var ue=w,We=w+h*(l-T);ue<=We;ue+=j){var de=ue+G;E?He(r[ue+i],r[de+i]):Se(r[ue+i],r[de+i]),se=te.a,r[de+i]=te.b,r[ue+i]=se}T=M,M>>=1}return w}function Me(r,i,l,h,f,p,x,E,y,M){for(var T=0,w=0,me=E,A=Math.trunc(f.value+(p+7)/8);f.value<A;)for(Be(T,w,l,f),T=J.c,w=J.lc;w>=14;){var B=T>>w-14&16383,G=i[B];if(G.len)w-=G.len,le(G.lit,x,T,w,l,h,f,y,M,me),T=ee.c,w=ee.lc;else{if(!G.p)throw"hufDecode issues";var j;for(j=0;j<G.lit;j++){for(var se=fe(r[G.p[j]]);w<se&&f.value<A;)Be(T,w,l,f),T=J.c,w=J.lc;if(w>=se&&ke(r[G.p[j]])==(T>>w-se&(1<<se)-1)){w-=se,le(G.p[j],x,T,w,l,h,f,y,M,me),T=ee.c,w=ee.lc;break}}if(j==G.lit)throw"hufDecode issues"}}var ce=8-p&7;for(T>>=ce,w-=ce;w>0;){var G=i[T<<14-w&16383];if(G.len)w-=G.len,le(G.lit,x,T,w,l,h,f,y,M,me),T=ee.c,w=ee.lc;else throw"hufDecode issues"}return!0}function ie(r,i,l,h,f,p){var x={value:0},E=l.value,y=Te(i,l),M=Te(i,l);l.value+=4;var T=Te(i,l);if(l.value+=4,y<0||y>=65537||M<0||M>=65537)throw"Something wrong with HUF_ENCSIZE";var w=new Array(65537),me=new Array(16384);P(me);var A=h-(l.value-E);if(F(r,i,l,A,y,M,w),T>8*(h-(l.value-E)))throw"Something wrong with hufUncompress";Ee(w,y,M,me),Me(w,me,r,i,l,T,M,p,f,x)}function je(r,i,l){for(var h=0;h<l;++h)i[h]=r[i[h]]}function Le(r){for(var i=1;i<r.length;i++){var l=r[i-1]+r[i]-128;r[i]=l}}function nt(r,i){for(var l=0,h=Math.floor((r.length+1)/2),f=0,p=r.length-1;!(f>p||(i[f++]=r[l++],f>p));)i[f++]=r[h++]}function ut(r){for(var i=r.byteLength,l=new Array,h=0,f=new DataView(r);i>0;){var p=f.getInt8(h++);if(p<0){var x=-p;i-=x+1;for(var E=0;E<x;E++)l.push(f.getUint8(h++))}else{var x=p;i-=2;for(var y=f.getUint8(h++),E=0;E<x+1;E++)l.push(y)}}return l}function Jt(r,i,l,h,f,p){var de=new DataView(p.buffer),x=l[r.idx[0]].width,E=l[r.idx[0]].height,y=3,M=Math.floor(x/8),T=Math.ceil(x/8),w=Math.ceil(E/8),me=x-(T-1)*8,A=E-(w-1)*8,B={value:0},G=new Array(y),j=new Array(y),se=new Array(y),ce=new Array(y),ve=new Array(y);for(let oe=0;oe<y;++oe)ve[oe]=i[r.idx[oe]],G[oe]=oe<1?0:G[oe-1]+T*w,j[oe]=new Float32Array(64),se[oe]=new Uint16Array(64),ce[oe]=new Uint16Array(T*64);for(let oe=0;oe<w;++oe){var ye=8;oe==w-1&&(ye=A);var ue=8;for(let pe=0;pe<T;++pe){pe==T-1&&(ue=me);for(let re=0;re<y;++re)se[re].fill(0),se[re][0]=f[G[re]++],Xe(B,h,se[re]),Ht(se[re],j[re]),St(j[re]);zt(j);for(let re=0;re<y;++re)en(j[re],ce[re],pe*64)}let _e=0;for(let pe=0;pe<y;++pe){const re=l[r.idx[pe]].type;for(let Fe=8*oe;Fe<8*oe+ye;++Fe){_e=ve[pe][Fe];for(let dt=0;dt<M;++dt){const Re=dt*64+(Fe&7)*8;de.setUint16(_e+0*2*re,ce[pe][Re+0],!0),de.setUint16(_e+1*2*re,ce[pe][Re+1],!0),de.setUint16(_e+2*2*re,ce[pe][Re+2],!0),de.setUint16(_e+3*2*re,ce[pe][Re+3],!0),de.setUint16(_e+4*2*re,ce[pe][Re+4],!0),de.setUint16(_e+5*2*re,ce[pe][Re+5],!0),de.setUint16(_e+6*2*re,ce[pe][Re+6],!0),de.setUint16(_e+7*2*re,ce[pe][Re+7],!0),_e+=8*2*re}}if(M!=T)for(let Fe=8*oe;Fe<8*oe+ye;++Fe){const dt=ve[pe][Fe]+8*M*2*re,Re=M*64+(Fe&7)*8;for(let rt=0;rt<ue;++rt)de.setUint16(dt+rt*2*re,ce[pe][Re+rt],!0)}}}for(var We=new Uint16Array(x),de=new DataView(p.buffer),ge=0;ge<y;++ge){l[r.idx[ge]].decoded=!0;var Ke=l[r.idx[ge]].type;if(l[ge].type==2)for(var Tt=0;Tt<E;++Tt){const oe=ve[ge][Tt];for(var Oe=0;Oe<x;++Oe)We[Oe]=de.getUint16(oe+Oe*2*Ke,!0);for(var Oe=0;Oe<x;++Oe)de.setFloat32(oe+Oe*2*Ke,C(We[Oe]),!0)}}}function Xe(r,i,l){for(var h,f=1;f<64;)h=i[r.value],h==65280?f=64:h>>8==255?f+=h&255:(l[f]=h,f++),r.value++}function Ht(r,i){i[0]=C(r[0]),i[1]=C(r[1]),i[2]=C(r[5]),i[3]=C(r[6]),i[4]=C(r[14]),i[5]=C(r[15]),i[6]=C(r[27]),i[7]=C(r[28]),i[8]=C(r[2]),i[9]=C(r[4]),i[10]=C(r[7]),i[11]=C(r[13]),i[12]=C(r[16]),i[13]=C(r[26]),i[14]=C(r[29]),i[15]=C(r[42]),i[16]=C(r[3]),i[17]=C(r[8]),i[18]=C(r[12]),i[19]=C(r[17]),i[20]=C(r[25]),i[21]=C(r[30]),i[22]=C(r[41]),i[23]=C(r[43]),i[24]=C(r[9]),i[25]=C(r[11]),i[26]=C(r[18]),i[27]=C(r[24]),i[28]=C(r[31]),i[29]=C(r[40]),i[30]=C(r[44]),i[31]=C(r[53]),i[32]=C(r[10]),i[33]=C(r[19]),i[34]=C(r[23]),i[35]=C(r[32]),i[36]=C(r[39]),i[37]=C(r[45]),i[38]=C(r[52]),i[39]=C(r[54]),i[40]=C(r[20]),i[41]=C(r[22]),i[42]=C(r[33]),i[43]=C(r[38]),i[44]=C(r[46]),i[45]=C(r[51]),i[46]=C(r[55]),i[47]=C(r[60]),i[48]=C(r[21]),i[49]=C(r[34]),i[50]=C(r[37]),i[51]=C(r[47]),i[52]=C(r[50]),i[53]=C(r[56]),i[54]=C(r[59]),i[55]=C(r[61]),i[56]=C(r[35]),i[57]=C(r[36]),i[58]=C(r[48]),i[59]=C(r[49]),i[60]=C(r[57]),i[61]=C(r[58]),i[62]=C(r[62]),i[63]=C(r[63])}function St(r){const i=.5*Math.cos(.7853975),l=.5*Math.cos(3.14159/16),h=.5*Math.cos(3.14159/8),f=.5*Math.cos(3*3.14159/16),p=.5*Math.cos(5*3.14159/16),x=.5*Math.cos(3*3.14159/8),E=.5*Math.cos(7*3.14159/16);for(var y=new Array(4),M=new Array(4),T=new Array(4),w=new Array(4),me=0;me<8;++me){var A=me*8;y[0]=h*r[A+2],y[1]=x*r[A+2],y[2]=h*r[A+6],y[3]=x*r[A+6],M[0]=l*r[A+1]+f*r[A+3]+p*r[A+5]+E*r[A+7],M[1]=f*r[A+1]-E*r[A+3]-l*r[A+5]-p*r[A+7],M[2]=p*r[A+1]-l*r[A+3]+E*r[A+5]+f*r[A+7],M[3]=E*r[A+1]-p*r[A+3]+f*r[A+5]-l*r[A+7],T[0]=i*(r[A+0]+r[A+4]),T[3]=i*(r[A+0]-r[A+4]),T[1]=y[0]+y[3],T[2]=y[1]-y[2],w[0]=T[0]+T[1],w[1]=T[3]+T[2],w[2]=T[3]-T[2],w[3]=T[0]-T[1],r[A+0]=w[0]+M[0],r[A+1]=w[1]+M[1],r[A+2]=w[2]+M[2],r[A+3]=w[3]+M[3],r[A+4]=w[3]-M[3],r[A+5]=w[2]-M[2],r[A+6]=w[1]-M[1],r[A+7]=w[0]-M[0]}for(var B=0;B<8;++B)y[0]=h*r[16+B],y[1]=x*r[16+B],y[2]=h*r[48+B],y[3]=x*r[48+B],M[0]=l*r[8+B]+f*r[24+B]+p*r[40+B]+E*r[56+B],M[1]=f*r[8+B]-E*r[24+B]-l*r[40+B]-p*r[56+B],M[2]=p*r[8+B]-l*r[24+B]+E*r[40+B]+f*r[56+B],M[3]=E*r[8+B]-p*r[24+B]+f*r[40+B]-l*r[56+B],T[0]=i*(r[B]+r[32+B]),T[3]=i*(r[B]-r[32+B]),T[1]=y[0]+y[3],T[2]=y[1]-y[2],w[0]=T[0]+T[1],w[1]=T[3]+T[2],w[2]=T[3]-T[2],w[3]=T[0]-T[1],r[0+B]=w[0]+M[0],r[8+B]=w[1]+M[1],r[16+B]=w[2]+M[2],r[24+B]=w[3]+M[3],r[32+B]=w[3]-M[3],r[40+B]=w[2]-M[2],r[48+B]=w[1]-M[1],r[56+B]=w[0]-M[0]}function zt(r){for(var i=0;i<64;++i){var l=r[0][i],h=r[1][i],f=r[2][i];r[0][i]=l+1.5747*f,r[1][i]=l-.1873*h-.4682*f,r[2][i]=l+1.8556*h}}function en(r,i,l){for(var h=0;h<64;++h)i[l+h]=pt.toHalfFloat(tn(r[h]))}function tn(r){return r<=1?Math.sign(r)*Math.pow(Math.abs(r),2.2):Math.sign(r)*Math.pow(S,Math.abs(r)-1)}function Gt(r){return new DataView(r.array.buffer,r.offset.value,r.size)}function nn(r){var i=r.viewer.buffer.slice(r.offset.value,r.offset.value+r.size),l=new Uint8Array(ut(i)),h=new Uint8Array(l.length);return Le(l),nt(l,h),new DataView(h.buffer)}function xt(r){var i=r.array.slice(r.offset.value,r.offset.value+r.size),l=$t(i),h=new Uint8Array(l.length);return Le(l),nt(l,h),new DataView(h.buffer)}function rn(r){for(var i=r.viewer,l={value:r.offset.value},h=new Uint16Array(r.width*r.scanlineBlockSize*(r.channels*r.type)),f=new Uint8Array(8192),p=0,x=new Array(r.channels),E=0;E<r.channels;E++)x[E]={},x[E].start=p,x[E].end=x[E].start,x[E].nx=r.width,x[E].ny=r.lines,x[E].size=r.type,p+=x[E].nx*x[E].ny*x[E].size;var y=wt(i,l),M=wt(i,l);if(M>=8192)throw"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";if(y<=M)for(var E=0;E<M-y+1;E++)f[E+y]=ht(i,l);var T=new Uint16Array(65536),w=U(f,T),me=Te(i,l);ie(r.array,i,l,me,h,p);for(var E=0;E<r.channels;++E)for(var A=x[E],B=0;B<x[E].size;++B)Ut(h,A.start+B,A.nx,A.size,A.ny,A.nx*A.size,w);je(T,h,p);for(var G=0,j=new Uint8Array(h.buffer.byteLength),se=0;se<r.lines;se++)for(var ce=0;ce<r.channels;ce++){var A=x[ce],ve=A.nx*A.size,ye=new Uint8Array(h.buffer,A.end*2,ve*2);j.set(ye,G),G+=ve*2,A.end+=ve}return new DataView(j.buffer)}function Ye(r){var i=r.array.slice(r.offset.value,r.offset.value+r.size),l=$t(i);const h=r.lines*r.channels*r.width,f=r.type==1?new Uint16Array(h):new Uint32Array(h);let p=0,x=0;const E=new Array(4);for(let y=0;y<r.lines;y++)for(let M=0;M<r.channels;M++){let T=0;switch(r.type){case 1:E[0]=p,E[1]=E[0]+r.width,p=E[1]+r.width;for(let w=0;w<r.width;++w){const me=l[E[0]++]<<8|l[E[1]++];T+=me,f[x]=T,x++}break;case 2:E[0]=p,E[1]=E[0]+r.width,E[2]=E[1]+r.width,p=E[2]+r.width;for(let w=0;w<r.width;++w){const me=l[E[0]++]<<24|l[E[1]++]<<16|l[E[2]++]<<8;T+=me,f[x]=T,x++}break}}return new DataView(f.buffer)}function Cn(r){var i=r.viewer,l={value:r.offset.value},h=new Uint8Array(r.width*r.lines*(r.channels*r.type*2)),f={version:Ne(i,l),unknownUncompressedSize:Ne(i,l),unknownCompressedSize:Ne(i,l),acCompressedSize:Ne(i,l),dcCompressedSize:Ne(i,l),rleCompressedSize:Ne(i,l),rleUncompressedSize:Ne(i,l),rleRawSize:Ne(i,l),totalAcUncompressedCount:Ne(i,l),totalDcUncompressedCount:Ne(i,l),acCompression:Ne(i,l)};if(f.version<2)throw"EXRLoader.parse: "+yt.compression+" version "+f.version+" is unsupported";for(var p=new Array,x=wt(i,l)-2;x>0;){var E=kt(i.buffer,l),y=ht(i,l),M=y>>2&3,T=(y>>4)-1,w=new Int8Array([T])[0],me=ht(i,l);p.push({name:E,index:w,type:me,compression:M}),x-=E.length+3}for(var A=yt.channels,B=new Array(r.channels),G=0;G<r.channels;++G){var j=B[G]={},se=A[G];j.name=se.name,j.compression=0,j.decoded=!1,j.type=se.pixelType,j.pLinear=se.pLinear,j.width=r.width,j.height=r.lines}for(var ce={idx:new Array(3)},ve=0;ve<r.channels;++ve)for(var j=B[ve],G=0;G<p.length;++G){var ye=p[G];j.name==ye.name&&(j.compression=ye.compression,ye.index>=0&&(ce.idx[ye.index]=ve),j.offset=ve)}if(f.acCompressedSize>0)switch(f.acCompression){case 0:var de=new Uint16Array(f.totalAcUncompressedCount);ie(r.array,i,l,f.acCompressedSize,de,f.totalAcUncompressedCount);break;case 1:var ue=r.array.slice(l.value,l.value+f.totalAcUncompressedCount),We=$t(ue),de=new Uint16Array(We.buffer);l.value+=f.totalAcUncompressedCount;break}if(f.dcCompressedSize>0){var ge={array:r.array,offset:l,size:f.dcCompressedSize},Ke=new Uint16Array(xt(ge).buffer);l.value+=f.dcCompressedSize}if(f.rleRawSize>0){var ue=r.array.slice(l.value,l.value+f.rleCompressedSize),We=$t(ue),Tt=ut(We.buffer);l.value+=f.rleCompressedSize}for(var Oe=0,oe=new Array(B.length),G=0;G<oe.length;++G)oe[G]=new Array;for(var _e=0;_e<r.lines;++_e)for(var pe=0;pe<B.length;++pe)oe[pe].push(Oe),Oe+=B[pe].width*r.type*2;Jt(ce,oe,B,de,Ke,h);for(var G=0;G<B.length;++G){var j=B[G];if(!j.decoded)switch(j.compression){case 2:for(var re=0,Fe=0,_e=0;_e<r.lines;++_e){for(var dt=oe[G][re],Re=0;Re<j.width;++Re){for(var rt=0;rt<2*j.type;++rt)h[dt++]=Tt[Fe+rt*j.width*j.height];Fe++}re++}break;case 1:default:throw"EXRLoader.parse: unsupported channel compression"}}return new DataView(h.buffer)}function kt(r,i){for(var l=new Uint8Array(r),h=0;l[i.value+h]!=0;)h+=1;var f=new TextDecoder().decode(l.slice(i.value,i.value+h));return i.value=i.value+h+1,f}function Mr(r,i,l){var h=new TextDecoder().decode(new Uint8Array(r).slice(i.value,i.value+l));return i.value=i.value+l,h}function yr(r,i){var l=_t(r,i),h=Te(r,i);return[l,h]}function Tr(r,i){var l=Te(r,i),h=Te(r,i);return[l,h]}function _t(r,i){var l=r.getInt32(i.value,!0);return i.value=i.value+4,l}function Te(r,i){var l=r.getUint32(i.value,!0);return i.value=i.value+4,l}function An(r,i){var l=r[i.value];return i.value=i.value+1,l}function ht(r,i){var l=r.getUint8(i.value);return i.value=i.value+1,l}const Ne=function(r,i){let l;return"getBigInt64"in DataView.prototype?l=Number(r.getBigInt64(i.value,!0)):l=r.getUint32(i.value+4,!0)+Number(r.getUint32(i.value,!0)<<32),i.value+=8,l};function xe(r,i){var l=r.getFloat32(i.value,!0);return i.value+=4,l}function br(r,i){return pt.toHalfFloat(xe(r,i))}function C(r){var i=(r&31744)>>10,l=r&1023;return(r>>15?-1:1)*(i?i===31?l?NaN:1/0:Math.pow(2,i-15)*(1+l/1024):6103515625e-14*(l/1024))}function wt(r,i){var l=r.getUint16(i.value,!0);return i.value+=2,l}function Rr(r,i){return C(wt(r,i))}function Cr(r,i,l,h){for(var f=l.value,p=[];l.value<f+h-1;){var x=kt(i,l),E=_t(r,l),y=ht(r,l);l.value+=3;var M=_t(r,l),T=_t(r,l);p.push({name:x,pixelType:E,pLinear:y,xSampling:M,ySampling:T})}return l.value+=1,p}function Ar(r,i){var l=xe(r,i),h=xe(r,i),f=xe(r,i),p=xe(r,i),x=xe(r,i),E=xe(r,i),y=xe(r,i),M=xe(r,i);return{redX:l,redY:h,greenX:f,greenY:p,blueX:x,blueY:E,whiteX:y,whiteY:M}}function Ir(r,i){var l=["NO_COMPRESSION","RLE_COMPRESSION","ZIPS_COMPRESSION","ZIP_COMPRESSION","PIZ_COMPRESSION","PXR24_COMPRESSION","B44_COMPRESSION","B44A_COMPRESSION","DWAA_COMPRESSION","DWAB_COMPRESSION"],h=ht(r,i);return l[h]}function Pr(r,i){var l=Te(r,i),h=Te(r,i),f=Te(r,i),p=Te(r,i);return{xMin:l,yMin:h,xMax:f,yMax:p}}function Dr(r,i){var l=["INCREASING_Y"],h=ht(r,i);return l[h]}function Br(r,i){var l=xe(r,i),h=xe(r,i);return[l,h]}function Lr(r,i){var l=xe(r,i),h=xe(r,i),f=xe(r,i);return[l,h,f]}function Nr(r,i,l,h,f){if(h==="string"||h==="stringvector"||h==="iccProfile")return Mr(i,l,f);if(h==="chlist")return Cr(r,i,l,f);if(h==="chromaticities")return Ar(r,l);if(h==="compression")return Ir(r,l);if(h==="box2i")return Pr(r,l);if(h==="lineOrder")return Dr(r,l);if(h==="float")return xe(r,l);if(h==="v2f")return Br(r,l);if(h==="v3f")return Lr(r,l);if(h==="int")return _t(r,l);if(h==="rational")return yr(r,l);if(h==="timecode")return Tr(r,l);if(h==="preview")return l.value+=f,"skipped";l.value+=f}function Or(r,i,l){const h={};if(r.getUint32(0,!0)!=20000630)throw"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";h.version=r.getUint8(4);const f=r.getUint8(5);h.spec={singleTile:!!(f&2),longName:!!(f&4),deepFormat:!!(f&8),multiPart:!!(f&16)},l.value=8;for(var p=!0;p;){var x=kt(i,l);if(x==0)p=!1;else{var E=kt(i,l),y=Te(r,l),M=Nr(r,i,l,E,y);M===void 0?console.warn(`EXRLoader.parse: skipped unknown header attribute type '${E}'.`):h[x]=M}}if(f&-5)throw console.error("EXRHeader:",h),"THREE.EXRLoader: provided file is currently unsupported.";return h}function Fr(r,i,l,h,f){const p={size:0,viewer:i,array:l,offset:h,width:r.dataWindow.xMax-r.dataWindow.xMin+1,height:r.dataWindow.yMax-r.dataWindow.yMin+1,channels:r.channels.length,bytesPerLine:null,lines:null,inputSize:null,type:r.channels[0].pixelType,uncompress:null,getter:null,format:null,[Ct?"colorSpace":"encoding"]:null};switch(r.compression){case"NO_COMPRESSION":p.lines=1,p.uncompress=Gt;break;case"RLE_COMPRESSION":p.lines=1,p.uncompress=nn;break;case"ZIPS_COMPRESSION":p.lines=1,p.uncompress=xt;break;case"ZIP_COMPRESSION":p.lines=16,p.uncompress=xt;break;case"PIZ_COMPRESSION":p.lines=32,p.uncompress=rn;break;case"PXR24_COMPRESSION":p.lines=16,p.uncompress=Ye;break;case"DWAA_COMPRESSION":p.lines=32,p.uncompress=Cn;break;case"DWAB_COMPRESSION":p.lines=256,p.uncompress=Cn;break;default:throw"EXRLoader.parse: "+r.compression+" is unsupported"}if(p.scanlineBlockSize=p.lines,p.type==1)switch(f){case $e:p.getter=Rr,p.inputSize=2;break;case Pe:p.getter=wt,p.inputSize=2;break}else if(p.type==2)switch(f){case $e:p.getter=xe,p.inputSize=4;break;case Pe:p.getter=br,p.inputSize=4}else throw"EXRLoader.parse: unsupported pixelType "+p.type+" for "+r.compression+".";p.blockCount=(r.dataWindow.yMax+1)/p.scanlineBlockSize;for(var x=0;x<p.blockCount;x++)Ne(i,h);p.outputChannels=p.channels==3?4:p.channels;const E=p.width*p.height*p.outputChannels;switch(f){case $e:p.byteArray=new Float32Array(E),p.channels<p.outputChannels&&p.byteArray.fill(1,0,E);break;case Pe:p.byteArray=new Uint16Array(E),p.channels<p.outputChannels&&p.byteArray.fill(15360,0,E);break;default:console.error("THREE.EXRLoader: unsupported type: ",f);break}return p.bytesPerLine=p.width*p.inputSize*p.channels,p.outputChannels==4?p.format=Dt:p.format=Qr,Ct?p.colorSpace="srgb-linear":p.encoding=3e3,p}const Vt=new DataView(t),Ur=new Uint8Array(t),Mt={value:0},yt=Or(Vt,t,Mt),Q=Fr(yt,Vt,Ur,Mt,this.type),In={value:0},Hr={R:0,G:1,B:2,A:3,Y:0};for(let r=0;r<Q.height/Q.scanlineBlockSize;r++){const i=Te(Vt,Mt);Q.size=Te(Vt,Mt),Q.lines=i+Q.scanlineBlockSize>Q.height?Q.height-i:Q.scanlineBlockSize;const h=Q.size<Q.lines*Q.bytesPerLine?Q.uncompress(Q):Gt(Q);Mt.value+=Q.size;for(let f=0;f<Q.scanlineBlockSize;f++){const p=f+r*Q.scanlineBlockSize;if(p>=Q.height)break;for(let x=0;x<Q.channels;x++){const E=Hr[yt.channels[x].name];for(let y=0;y<Q.width;y++){In.value=(f*(Q.channels*Q.width)+x*Q.width+y)*Q.inputSize;const M=(Q.height-1-p)*(Q.width*Q.outputChannels)+y*Q.outputChannels+E;Q.byteArray[M]=Q.getter(h,In)}}}}return{header:yt,width:Q.width,height:Q.height,data:Q.byteArray,format:Q.format,[Ct?"colorSpace":"encoding"]:Q[Ct?"colorSpace":"encoding"],type:this.type}}setDataType(t){return this.type=t,this}load(t,n,a,s){function o(c,u){Ct?c.colorSpace=u.colorSpace:c.encoding=u.encoding,c.minFilter=be,c.magFilter=be,c.generateMipmaps=!1,c.flipY=!1,n&&n(c,u)}return super.load(t,o,a,s)}}const pa=3e3,ma=3001,fr=(e,t,n)=>{let a;switch(e){case ct:a=new Uint8ClampedArray(t*n*4);break;case Pe:a=new Uint16Array(t*n*4);break;case Jn:a=new Uint32Array(t*n*4);break;case ni:a=new Int8Array(t*n*4);break;case ti:a=new Int16Array(t*n*4);break;case ei:a=new Int32Array(t*n*4);break;case $e:a=new Float32Array(t*n*4);break;default:throw new Error("Unsupported data type")}return a};let jt;const va=(e,t,n,a)=>{if(jt!==void 0)return jt;const s=new Ge(1,1,a);t.setRenderTarget(s);const o=new Nt(new qn,new er({color:16777215}));t.render(o,n),t.setRenderTarget(null);const c=fr(e,s.width,s.height);return t.readRenderTargetPixels(s,0,0,s.width,s.height,c),s.dispose(),o.geometry.dispose(),o.material.dispose(),jt=c[0]!==0,jt};class xn{constructor(t){var n,a,s,o,c,u,d,m,v,g,R,I,Z,Y,H,k;this._rendererIsDisposable=!1,this._supportsReadPixels=!0,this.render=()=>{this._renderer.setRenderTarget(this._renderTarget);try{this._renderer.render(this._scene,this._camera)}catch(D){throw this._renderer.setRenderTarget(null),D}this._renderer.setRenderTarget(null)},this._width=t.width,this._height=t.height,this._type=t.type,this._colorSpace=t.colorSpace;const L={format:Dt,depthBuffer:!1,stencilBuffer:!1,type:this._type,colorSpace:this._colorSpace,anisotropy:((n=t.renderTargetOptions)===null||n===void 0?void 0:n.anisotropy)!==void 0?(a=t.renderTargetOptions)===null||a===void 0?void 0:a.anisotropy:1,generateMipmaps:((s=t.renderTargetOptions)===null||s===void 0?void 0:s.generateMipmaps)!==void 0?(o=t.renderTargetOptions)===null||o===void 0?void 0:o.generateMipmaps:!1,magFilter:((c=t.renderTargetOptions)===null||c===void 0?void 0:c.magFilter)!==void 0?(u=t.renderTargetOptions)===null||u===void 0?void 0:u.magFilter:be,minFilter:((d=t.renderTargetOptions)===null||d===void 0?void 0:d.minFilter)!==void 0?(m=t.renderTargetOptions)===null||m===void 0?void 0:m.minFilter:be,samples:((v=t.renderTargetOptions)===null||v===void 0?void 0:v.samples)!==void 0?(g=t.renderTargetOptions)===null||g===void 0?void 0:g.samples:void 0,wrapS:((R=t.renderTargetOptions)===null||R===void 0?void 0:R.wrapS)!==void 0?(I=t.renderTargetOptions)===null||I===void 0?void 0:I.wrapS:st,wrapT:((Z=t.renderTargetOptions)===null||Z===void 0?void 0:Z.wrapT)!==void 0?(Y=t.renderTargetOptions)===null||Y===void 0?void 0:Y.wrapT:st};if(this._material=t.material,t.renderer?this._renderer=t.renderer:(this._renderer=xn.instantiateRenderer(),this._rendererIsDisposable=!0),this._scene=new Yt,this._camera=new mn,this._camera.position.set(0,0,10),this._camera.left=-.5,this._camera.right=.5,this._camera.top=.5,this._camera.bottom=-.5,this._camera.updateProjectionMatrix(),!va(this._type,this._renderer,this._camera,L)){let D;switch(this._type){case Pe:D=this._renderer.extensions.has("EXT_color_buffer_float")?$e:void 0;break}D!==void 0?(console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${$e}`),this._type=D):(this._supportsReadPixels=!1,console.warn("This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown"))}this._quad=new Nt(new qn,this._material),this._quad.geometry.computeBoundingBox(),this._scene.add(this._quad),this._renderTarget=new Ge(this.width,this.height,L),this._renderTarget.texture.mapping=((H=t.renderTargetOptions)===null||H===void 0?void 0:H.mapping)!==void 0?(k=t.renderTargetOptions)===null||k===void 0?void 0:k.mapping:Kt}static instantiateRenderer(){const t=new qr;return t.setSize(128,128),t}toArray(){if(!this._supportsReadPixels)throw new Error("Can't read pixels in this browser");const t=fr(this._type,this._width,this._height);return this._renderer.readRenderTargetPixels(this._renderTarget,0,0,this._width,this._height,t),t}toDataTexture(t){const n=new Jr(this.toArray(),this.width,this.height,Dt,this._type,(t==null?void 0:t.mapping)||Kt,(t==null?void 0:t.wrapS)||st,(t==null?void 0:t.wrapT)||st,(t==null?void 0:t.magFilter)||be,(t==null?void 0:t.minFilter)||be,(t==null?void 0:t.anisotropy)||1,Bt);return n.generateMipmaps=(t==null?void 0:t.generateMipmaps)!==void 0?t==null?void 0:t.generateMipmaps:!1,n}disposeOnDemandRenderer(){this._renderer.setRenderTarget(null),this._rendererIsDisposable&&(this._renderer.dispose(),this._renderer.forceContextLoss())}dispose(t){this.disposeOnDemandRenderer(),t&&this.renderTarget.dispose(),this.material instanceof tt&&Object.values(this.material.uniforms).forEach(n=>{n.value instanceof ot&&n.value.dispose()}),Object.values(this.material).forEach(n=>{n instanceof ot&&n.dispose()}),this.material.dispose(),this._quad.geometry.dispose()}get width(){return this._width}set width(t){this._width=t,this._renderTarget.setSize(this._width,this._height)}get height(){return this._height}set height(t){this._height=t,this._renderTarget.setSize(this._width,this._height)}get renderer(){return this._renderer}get renderTarget(){return this._renderTarget}set renderTarget(t){this._renderTarget=t,this._width=t.width,this._height=t.height}get material(){return this._material}get type(){return this._type}get colorSpace(){return this._colorSpace}}const ga=`
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,Ea=`
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`;class Sa extends tt{constructor({gamma:t,offsetHdr:n,offsetSdr:a,gainMapMin:s,gainMapMax:o,maxDisplayBoost:c,hdrCapacityMin:u,hdrCapacityMax:d,sdr:m,gainMap:v}){super({name:"GainMapDecoderMaterial",vertexShader:ga,fragmentShader:Ea,uniforms:{sdr:{value:m},gainMap:{value:v},gamma:{value:new Qe(1/t[0],1/t[1],1/t[2])},offsetHdr:{value:new Qe().fromArray(n)},offsetSdr:{value:new Qe().fromArray(a)},gainMapMin:{value:new Qe().fromArray(s)},gainMapMax:{value:new Qe().fromArray(o)},weightFactor:{value:(Math.log2(c)-u)/(d-u)}},blending:gt,depthTest:!1,depthWrite:!1}),this._maxDisplayBoost=c,this._hdrCapacityMin=u,this._hdrCapacityMax=d,this.needsUpdate=!0,this.uniformsNeedUpdate=!0}get sdr(){return this.uniforms.sdr.value}set sdr(t){this.uniforms.sdr.value=t}get gainMap(){return this.uniforms.gainMap.value}set gainMap(t){this.uniforms.gainMap.value=t}get offsetHdr(){return this.uniforms.offsetHdr.value.toArray()}set offsetHdr(t){this.uniforms.offsetHdr.value.fromArray(t)}get offsetSdr(){return this.uniforms.offsetSdr.value.toArray()}set offsetSdr(t){this.uniforms.offsetSdr.value.fromArray(t)}get gainMapMin(){return this.uniforms.gainMapMin.value.toArray()}set gainMapMin(t){this.uniforms.gainMapMin.value.fromArray(t)}get gainMapMax(){return this.uniforms.gainMapMax.value.toArray()}set gainMapMax(t){this.uniforms.gainMapMax.value.fromArray(t)}get gamma(){const t=this.uniforms.gamma.value;return[1/t.x,1/t.y,1/t.z]}set gamma(t){const n=this.uniforms.gamma.value;n.x=1/t[0],n.y=1/t[1],n.z=1/t[2]}get hdrCapacityMin(){return this._hdrCapacityMin}set hdrCapacityMin(t){this._hdrCapacityMin=t,this.calculateWeight()}get hdrCapacityMax(){return this._hdrCapacityMax}set hdrCapacityMax(t){this._hdrCapacityMax=t,this.calculateWeight()}get maxDisplayBoost(){return this._maxDisplayBoost}set maxDisplayBoost(t){this._maxDisplayBoost=Math.max(1,Math.min(65504,t)),this.calculateWeight()}calculateWeight(){const t=(Math.log2(this._maxDisplayBoost)-this._hdrCapacityMin)/(this._hdrCapacityMax-this._hdrCapacityMin);this.uniforms.weightFactor.value=Math.max(0,Math.min(1,t))}}class pr extends Error{}class mr extends Error{}const At=(e,t,n)=>{const a=new RegExp(`${t}="([^"]*)"`,"i").exec(e);if(a)return a[1];const s=new RegExp(`<${t}[^>]*>([\\s\\S]*?)</${t}>`,"i").exec(e);if(s){const o=s[1].match(/<rdf:li>([^<]*)<\/rdf:li>/g);return o&&o.length===3?o.map(c=>c.replace(/<\/?rdf:li>/g,"")):s[1].trim()}if(n!==void 0)return n;throw new Error(`Can't find ${t} in gainmap metadata`)},xa=e=>{let t;typeof TextDecoder<"u"?t=new TextDecoder().decode(e):t=e.toString();let n=t.indexOf("<x:xmpmeta");for(;n!==-1;){const a=t.indexOf("x:xmpmeta>",n),s=t.slice(n,a+10);try{const o=At(s,"hdrgm:GainMapMin","0"),c=At(s,"hdrgm:GainMapMax"),u=At(s,"hdrgm:Gamma","1"),d=At(s,"hdrgm:OffsetSDR","0.015625"),m=At(s,"hdrgm:OffsetHDR","0.015625"),v=/hdrgm:HDRCapacityMin="([^"]*)"/.exec(s),g=v?v[1]:"0",R=/hdrgm:HDRCapacityMax="([^"]*)"/.exec(s);if(!R)throw new Error("Incomplete gainmap metadata");const I=R[1];return{gainMapMin:Array.isArray(o)?o.map(Z=>parseFloat(Z)):[parseFloat(o),parseFloat(o),parseFloat(o)],gainMapMax:Array.isArray(c)?c.map(Z=>parseFloat(Z)):[parseFloat(c),parseFloat(c),parseFloat(c)],gamma:Array.isArray(u)?u.map(Z=>parseFloat(Z)):[parseFloat(u),parseFloat(u),parseFloat(u)],offsetSdr:Array.isArray(d)?d.map(Z=>parseFloat(Z)):[parseFloat(d),parseFloat(d),parseFloat(d)],offsetHdr:Array.isArray(m)?m.map(Z=>parseFloat(Z)):[parseFloat(m),parseFloat(m),parseFloat(m)],hdrCapacityMin:parseFloat(g),hdrCapacityMax:parseFloat(I)}}catch{}n=t.indexOf("<x:xmpmeta",a)}};class _a{constructor(t){this.options={debug:t&&t.debug!==void 0?t.debug:!1,extractFII:t&&t.extractFII!==void 0?t.extractFII:!0,extractNonFII:t&&t.extractNonFII!==void 0?t.extractNonFII:!0}}extract(t){return new Promise((n,a)=>{const s=this.options.debug,o=new DataView(t.buffer);if(o.getUint16(0)!==65496){a(new Error("Not a valid jpeg"));return}const c=o.byteLength;let u=2,d=0,m;for(;u<c;){if(++d>250){a(new Error(`Found no marker after ${d} loops `));return}if(o.getUint8(u)!==255){a(new Error(`Not a valid marker at offset 0x${u.toString(16)}, found: 0x${o.getUint8(u).toString(16)}`));return}if(m=o.getUint8(u+1),s&&console.log(`Marker: ${m.toString(16)}`),m===226){s&&console.log("Found APP2 marker (0xffe2)");const v=u+4;if(o.getUint32(v)===1297106432){const g=v+4;let R;if(o.getUint16(g)===18761)R=!1;else if(o.getUint16(g)===19789)R=!0;else{a(new Error("No valid endianness marker found in TIFF header"));return}if(o.getUint16(g+2,!R)!==42){a(new Error("Not valid TIFF data! (no 0x002A marker)"));return}const I=o.getUint32(g+4,!R);if(I<8){a(new Error("Not valid TIFF data! (First offset less than 8)"));return}const Z=g+I,Y=o.getUint16(Z,!R),H=Z+2;let k=0;for(let V=H;V<H+12*Y;V+=12)o.getUint16(V,!R)===45057&&(k=o.getUint32(V+8,!R));const D=Z+2+Y*12+4,K=[];for(let V=D;V<D+k*16;V+=16){const O={MPType:o.getUint32(V,!R),size:o.getUint32(V+4,!R),dataOffset:o.getUint32(V+8,!R),dependantImages:o.getUint32(V+12,!R),start:-1,end:-1,isFII:!1};O.dataOffset?(O.start=g+O.dataOffset,O.isFII=!1):(O.start=0,O.isFII=!0),O.end=O.start+O.size,K.push(O)}if(this.options.extractNonFII&&K.length){const V=new Blob([o]),O=[];for(const ne of K){if(ne.isFII&&!this.options.extractFII)continue;const _=V.slice(ne.start,ne.end+1,"image/jpeg");O.push(_)}n(O)}}}u+=2+o.getUint16(u+2)}})}}const wa=async e=>{const t=xa(e);if(!t)throw new mr("Gain map XMP metadata not found");const a=await new _a({extractFII:!0,extractNonFII:!0}).extract(e);if(a.length!==2)throw new pr("Gain map recovery image not found");return{sdr:new Uint8Array(await a[0].arrayBuffer()),gainMap:new Uint8Array(await a[1].arrayBuffer()),metadata:t}},Fn=e=>new Promise((t,n)=>{const a=document.createElement("img");a.onload=()=>{t(a)},a.onerror=s=>{n(s)},a.src=URL.createObjectURL(e)});class vr extends ri{constructor(t,n){super(n),t&&(this._renderer=t),this._internalLoadingManager=new ii}setRenderer(t){return this._renderer=t,this}setRenderTargetOptions(t){return this._renderTargetOptions=t,this}prepareQuadRenderer(){this._renderer||console.warn("WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.");const t=new Sa({gainMapMax:[1,1,1],gainMapMin:[0,0,0],gamma:[1,1,1],offsetHdr:[1,1,1],offsetSdr:[1,1,1],hdrCapacityMax:1,hdrCapacityMin:0,maxDisplayBoost:1,gainMap:new ot,sdr:new ot});return new xn({width:16,height:16,type:Pe,colorSpace:Bt,material:t,renderer:this._renderer,renderTargetOptions:this._renderTargetOptions})}async render(t,n,a,s){const o=s?new Blob([s],{type:"image/jpeg"}):void 0,c=new Blob([a],{type:"image/jpeg"});let u,d,m=!1;if(typeof createImageBitmap>"u"){const R=await Promise.all([o?Fn(o):Promise.resolve(void 0),Fn(c)]);d=R[0],u=R[1],m=!0}else{const R=await Promise.all([o?createImageBitmap(o,{imageOrientation:"flipY"}):Promise.resolve(void 0),createImageBitmap(c,{imageOrientation:"flipY"})]);d=R[0],u=R[1]}const v=new ot(d||new ImageData(2,2),Kt,st,st,be,Pn,Dt,ct,1,Bt);v.flipY=m,v.needsUpdate=!0;const g=new ot(u,Kt,st,st,be,Pn,Dt,ct,1,Ze);g.flipY=m,g.needsUpdate=!0,t.width=u.width,t.height=u.height,t.material.gainMap=v,t.material.sdr=g,t.material.gainMapMin=n.gainMapMin,t.material.gainMapMax=n.gainMapMax,t.material.offsetHdr=n.offsetHdr,t.material.offsetSdr=n.offsetSdr,t.material.gamma=n.gamma,t.material.hdrCapacityMin=n.hdrCapacityMin,t.material.hdrCapacityMax=n.hdrCapacityMax,t.material.maxDisplayBoost=Math.pow(2,n.hdrCapacityMax),t.material.needsUpdate=!0,t.render()}}class Ma extends vr{load([t,n,a],s,o,c){const u=this.prepareQuadRenderer();let d,m,v;const g=async()=>{if(d&&m&&v){try{await this.render(u,v,d,m)}catch(S){this.manager.itemError(t),this.manager.itemError(n),this.manager.itemError(a),typeof c=="function"&&c(S),u.disposeOnDemandRenderer();return}typeof s=="function"&&s(u),this.manager.itemEnd(t),this.manager.itemEnd(n),this.manager.itemEnd(a),u.disposeOnDemandRenderer()}};let R=!0,I=0,Z=0,Y=!0,H=0,k=0,L=!0,D=0,K=0;const V=()=>{if(typeof o=="function"){const S=I+H+D,U=Z+k+K,P=R&&Y&&L;o(new ProgressEvent("progress",{lengthComputable:P,loaded:U,total:S}))}};this.manager.itemStart(t),this.manager.itemStart(n),this.manager.itemStart(a);const O=new Xt(this._internalLoadingManager);O.setResponseType("arraybuffer"),O.setRequestHeader(this.requestHeader),O.setPath(this.path),O.setWithCredentials(this.withCredentials),O.load(t,async S=>{if(typeof S=="string")throw new Error("Invalid sdr buffer");d=S,await g()},S=>{R=S.lengthComputable,Z=S.loaded,I=S.total,V()},S=>{this.manager.itemError(t),typeof c=="function"&&c(S)});const ne=new Xt(this._internalLoadingManager);ne.setResponseType("arraybuffer"),ne.setRequestHeader(this.requestHeader),ne.setPath(this.path),ne.setWithCredentials(this.withCredentials),ne.load(n,async S=>{if(typeof S=="string")throw new Error("Invalid gainmap buffer");m=S,await g()},S=>{Y=S.lengthComputable,k=S.loaded,H=S.total,V()},S=>{this.manager.itemError(n),typeof c=="function"&&c(S)});const _=new Xt(this._internalLoadingManager);return _.setRequestHeader(this.requestHeader),_.setPath(this.path),_.setWithCredentials(this.withCredentials),_.load(a,async S=>{if(typeof S!="string")throw new Error("Invalid metadata string");v=JSON.parse(S),await g()},S=>{L=S.lengthComputable,K=S.loaded,D=S.total,V()},S=>{this.manager.itemError(a),typeof c=="function"&&c(S)}),u}}class ya extends vr{load(t,n,a,s){const o=this.prepareQuadRenderer(),c=new Xt(this._internalLoadingManager);return c.setResponseType("arraybuffer"),c.setRequestHeader(this.requestHeader),c.setPath(this.path),c.setWithCredentials(this.withCredentials),this.manager.itemStart(t),c.load(t,async u=>{if(typeof u=="string")throw new Error("Invalid buffer, received [string], was expecting [ArrayBuffer]");const d=new Uint8Array(u);let m,v,g;try{const R=await wa(d);m=R.sdr,v=R.gainMap,g=R.metadata}catch(R){if(R instanceof mr||R instanceof pr)console.warn(`Failure to reconstruct an HDR image from ${t}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`),g={gainMapMin:[0,0,0],gainMapMax:[1,1,1],gamma:[1,1,1],hdrCapacityMin:0,hdrCapacityMax:1,offsetHdr:[0,0,0],offsetSdr:[0,0,0]},m=d;else throw R}try{await this.render(o,g,m,v)}catch(R){this.manager.itemError(t),typeof s=="function"&&s(R),o.disposeOnDemandRenderer();return}typeof n=="function"&&n(o),this.manager.itemEnd(t),o.disposeOnDemandRenderer()},a,u=>{this.manager.itemError(t),typeof s=="function"&&s(u)}),o}}const Lt={apartment:"lebombo_1k.hdr",city:"potsdamer_platz_1k.hdr",dawn:"kiara_1_dawn_1k.hdr",forest:"forest_slope_1k.hdr",lobby:"st_fagans_interior_1k.hdr",night:"dikhololo_night_1k.hdr",park:"rooitou_park_1k.hdr",studio:"studio_small_03_1k.hdr",sunset:"venice_sunset_1k.hdr",warehouse:"empty_warehouse_01_1k.hdr"},gr="https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/",mt=e=>Array.isArray(e),_n=["/px.png","/nx.png","/py.png","/ny.png","/pz.png","/nz.png"];function qt({files:e=_n,path:t="",preset:n=void 0,encoding:a=void 0,extensions:s}={}){let o=null,c=!1;n&&(wn(n),e=Lt[n],t=gr),c=mt(e);const{extension:u,isCubemap:d}=Mn(e);if(o=yn(u),!o)throw new Error("useEnvironment: Unrecognized file extension: "+e);const m=et(I=>I.gl);b.useLayoutEffect(()=>{if(u!=="webp"&&u!=="jpg"&&u!=="jpeg")return;function I(){Qt.clear(o,c?[e]:e)}m.domElement.addEventListener("webglcontextlost",I,{once:!0})},[e,m.domElement]);const v=Qt(o,c?[e]:e,I=>{(u==="webp"||u==="jpg"||u==="jpeg")&&I.setRenderer(m),I.setPath==null||I.setPath(t),s&&s(I)});let g=c?v[0]:v;if(u==="jpg"||u==="jpeg"||u==="webp"){var R;g=(R=g.renderTarget)==null?void 0:R.texture}return g.mapping=d?ai:si,"colorSpace"in g?g.colorSpace=a??d?"srgb":"srgb-linear":g.encoding=a??d?ma:pa,g}const Ta={files:_n,path:"",preset:void 0,extensions:void 0};qt.preload=e=>{const t={...Ta,...e};let{files:n,path:a=""}=t;const{preset:s,extensions:o}=t;s&&(wn(s),n=Lt[s],a=gr);const{extension:c}=Mn(n);if(c==="webp"||c==="jpg"||c==="jpeg")throw new Error("useEnvironment: Preloading gainmaps is not supported");const u=yn(c);if(!u)throw new Error("useEnvironment: Unrecognized file extension: "+n);Qt.preload(u,mt(n)?[n]:n,d=>{d.setPath==null||d.setPath(a),o&&o(d)})};const ba={files:_n,preset:void 0};qt.clear=e=>{const t={...ba,...e};let{files:n}=t;const{preset:a}=t;a&&(wn(a),n=Lt[a]);const{extension:s}=Mn(n),o=yn(s);if(!o)throw new Error("useEnvironment: Unrecognized file extension: "+n);Qt.clear(o,mt(n)?[n]:n)};function wn(e){if(!(e in Lt))throw new Error("Preset must be one of: "+Object.keys(Lt).join(", "))}function Mn(e){var t;const n=mt(e)&&e.length===6,a=mt(e)&&e.length===3&&e.some(c=>c.endsWith("json")),s=mt(e)?e[0]:e;return{extension:n?"cube":a?"webp":s.startsWith("data:application/exr")?"exr":s.startsWith("data:application/hdr")?"hdr":s.startsWith("data:image/jpeg")?"jpg":(t=s.split(".").pop())==null||(t=t.split("?"))==null||(t=t.shift())==null?void 0:t.toLowerCase(),isCubemap:n,isGainmap:a}}function yn(e){return e==="cube"?oi:e==="hdr"?ha:e==="exr"?fa:e==="jpg"||e==="jpeg"?ya:e==="webp"?Ma:null}const Ra=e=>e.current&&e.current.isScene,Ca=e=>Ra(e)?e.current:e;function Tn(e,t,n,a,s={}){var o,c,u,d;s={backgroundBlurriness:0,backgroundIntensity:1,backgroundRotation:[0,0,0],environmentIntensity:1,environmentRotation:[0,0,0],...s};const m=Ca(t||n),v=m.background,g=m.environment,R={backgroundBlurriness:m.backgroundBlurriness,backgroundIntensity:m.backgroundIntensity,backgroundRotation:(o=(c=m.backgroundRotation)==null||c.clone==null?void 0:c.clone())!==null&&o!==void 0?o:[0,0,0],environmentIntensity:m.environmentIntensity,environmentRotation:(u=(d=m.environmentRotation)==null||d.clone==null?void 0:d.clone())!==null&&u!==void 0?u:[0,0,0]};return e!=="only"&&(m.environment=a),e&&(m.background=a),Dn(m,s),()=>{e!=="only"&&(m.environment=g),e&&(m.background=v),Dn(m,R)}}function bn({scene:e,background:t=!1,map:n,...a}){const s=et(o=>o.scene);return b.useLayoutEffect(()=>{if(n)return Tn(t,e,s,n,a)}),null}function Er({background:e=!1,scene:t,blur:n,backgroundBlurriness:a,backgroundIntensity:s,backgroundRotation:o,environmentIntensity:c,environmentRotation:u,...d}){const m=qt(d),v=et(g=>g.scene);return b.useLayoutEffect(()=>Tn(e,t,v,m,{backgroundBlurriness:n??a,backgroundIntensity:s,backgroundRotation:o,environmentIntensity:c,environmentRotation:u})),b.useEffect(()=>()=>{m.dispose()},[m]),null}function Aa({children:e,near:t=.1,far:n=1e3,resolution:a=256,frames:s=1,map:o,background:c=!1,blur:u,backgroundBlurriness:d,backgroundIntensity:m,backgroundRotation:v,environmentIntensity:g,environmentRotation:R,scene:I,files:Z,path:Y,preset:H=void 0,extensions:k}){const L=et(_=>_.gl),D=et(_=>_.scene),K=b.useRef(null),[V]=b.useState(()=>new Yt),O=b.useMemo(()=>{const _=new li(a);return _.texture.type=Pe,_},[a]);b.useEffect(()=>()=>{O.dispose()},[O]),b.useLayoutEffect(()=>{if(s===1){const _=L.autoClear;L.autoClear=!0,K.current.update(L,V),L.autoClear=_}return Tn(c,I,D,O.texture,{backgroundBlurriness:u??d,backgroundIntensity:m,backgroundRotation:v,environmentIntensity:g,environmentRotation:R})},[e,V,O.texture,I,D,c,s,L]);let ne=1;return pn(()=>{if(s===1/0||ne<s){const _=L.autoClear;L.autoClear=!0,K.current.update(L,V),L.autoClear=_,ne++}}),b.createElement(b.Fragment,null,ci(b.createElement(b.Fragment,null,e,b.createElement("cubeCamera",{ref:K,args:[t,n,O]}),Z||H?b.createElement(Er,{background:!0,files:Z,preset:H,path:Y,extensions:k}):o?b.createElement(bn,{background:!0,map:o,extensions:k}):null),V))}function Ia(e){var t,n,a,s;const o=qt(e),c=e.map||o;b.useMemo(()=>tr({GroundProjectedEnvImpl:da}),[]),b.useEffect(()=>()=>{o.dispose()},[o]);const u=b.useMemo(()=>[c],[c]),d=(t=e.ground)==null?void 0:t.height,m=(n=e.ground)==null?void 0:n.radius,v=(a=(s=e.ground)==null?void 0:s.scale)!==null&&a!==void 0?a:1e3;return b.createElement(b.Fragment,null,b.createElement(bn,Yn({},e,{map:c})),b.createElement("groundProjectedEnvImpl",{args:u,scale:v,height:d,radius:m}))}function js(e){return e.ground?b.createElement(Ia,e):e.map?b.createElement(bn,e):e.children?b.createElement(Aa,e):b.createElement(Er,e)}/**
 * postprocessing v6.36.6 build Tue Dec 31 2024
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2024 Raoul van Rschen
 * @license Zlib
 */var on=1/1e3,Pa=1e3,Da=class{constructor(){this.startTime=performance.now(),this.previousTime=0,this.currentTime=0,this._delta=0,this._elapsed=0,this._fixedDelta=1e3/60,this.timescale=1,this.useFixedDelta=!1,this._autoReset=!1}get autoReset(){return this._autoReset}set autoReset(e){typeof document<"u"&&document.hidden!==void 0&&(e?document.addEventListener("visibilitychange",this):document.removeEventListener("visibilitychange",this),this._autoReset=e)}get delta(){return this._delta*on}get fixedDelta(){return this._fixedDelta*on}set fixedDelta(e){this._fixedDelta=e*Pa}get elapsed(){return this._elapsed*on}update(e){this.useFixedDelta?this._delta=this.fixedDelta:(this.previousTime=this.currentTime,this.currentTime=(e!==void 0?e:performance.now())-this.startTime,this._delta=this.currentTime-this.previousTime),this._delta*=this.timescale,this._elapsed+=this._delta}reset(){this._delta=0,this._elapsed=0,this.currentTime=performance.now()-this.startTime}getDelta(){return this.delta}getElapsed(){return this.elapsed}handleEvent(e){document.hidden||(this.currentTime=performance.now()-this.startTime)}dispose(){this.autoReset=!1}},Ba=(()=>{const e=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),t=new Float32Array([0,0,2,0,0,2]),n=new gi;return n.setAttribute("position",new Bn(e,3)),n.setAttribute("uv",new Bn(t,2)),n})(),De=class hn{static get fullscreenGeometry(){return Ba}constructor(t="Pass",n=new Yt,a=new pi){this.name=t,this.renderer=null,this.scene=n,this.camera=a,this.screen=null,this.rtt=!0,this.needsSwap=!0,this.needsDepthTexture=!1,this.enabled=!0}get renderToScreen(){return!this.rtt}set renderToScreen(t){if(this.rtt===t){const n=this.fullscreenMaterial;n!==null&&(n.needsUpdate=!0),this.rtt=!t}}set mainScene(t){}set mainCamera(t){}setRenderer(t){this.renderer=t}isEnabled(){return this.enabled}setEnabled(t){this.enabled=t}get fullscreenMaterial(){return this.screen!==null?this.screen.material:null}set fullscreenMaterial(t){let n=this.screen;n!==null?n.material=t:(n=new Nt(hn.fullscreenGeometry,t),n.frustumCulled=!1,this.scene===null&&(this.scene=new Yt),this.scene.add(n),this.screen=n)}getFullscreenMaterial(){return this.fullscreenMaterial}setFullscreenMaterial(t){this.fullscreenMaterial=t}getDepthTexture(){return null}setDepthTexture(t,n=Et){}render(t,n,a,s,o){throw new Error("Render method not implemented!")}setSize(t,n){}initialize(t,n,a){}dispose(){for(const t of Object.keys(this)){const n=this[t];(n instanceof Ge||n instanceof ir||n instanceof ot||n instanceof hn)&&this[t].dispose()}this.fullscreenMaterial!==null&&this.fullscreenMaterial.dispose()}},La=class extends De{constructor(){super("ClearMaskPass",null,null),this.needsSwap=!1}render(e,t,n,a,s){const o=e.state.buffers.stencil;o.setLocked(!1),o.setTest(!1)}},Na=`#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <colorspace_fragment>
#include <dithering_fragment>
}`,Rn="varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",Oa=class extends tt{constructor(){super({name:"CopyMaterial",uniforms:{inputBuffer:new ae(null),opacity:new ae(1)},blending:gt,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:Na,vertexShader:Rn})}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}getOpacity(e){return this.uniforms.opacity.value}setOpacity(e){this.uniforms.opacity.value=e}},Sr=class extends De{constructor(e,t=!0){super("CopyPass"),this.fullscreenMaterial=new Oa,this.needsSwap=!1,this.renderTarget=e,e===void 0&&(this.renderTarget=new Ge(1,1,{minFilter:be,magFilter:be,stencilBuffer:!1,depthBuffer:!1}),this.renderTarget.texture.name="CopyPass.Target"),this.autoResize=t}get resize(){return this.autoResize}set resize(e){this.autoResize=e}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}setAutoResizeEnabled(e){this.autoResize=e}render(e,t,n,a,s){this.fullscreenMaterial.inputBuffer=t.texture,e.setRenderTarget(this.renderToScreen?null:this.renderTarget),e.render(this.scene,this.camera)}setSize(e,t){this.autoResize&&this.renderTarget.setSize(e,t)}initialize(e,t,n){n!==void 0&&(this.renderTarget.texture.type=n,n!==ct?this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1":e!==null&&e.outputColorSpace===Ze&&(this.renderTarget.texture.colorSpace=Ze))}},Un=new rr,xr=class extends De{constructor(e=!0,t=!0,n=!1){super("ClearPass",null,null),this.needsSwap=!1,this.color=e,this.depth=t,this.stencil=n,this.overrideClearColor=null,this.overrideClearAlpha=-1}setClearFlags(e,t,n){this.color=e,this.depth=t,this.stencil=n}getOverrideClearColor(){return this.overrideClearColor}setOverrideClearColor(e){this.overrideClearColor=e}getOverrideClearAlpha(){return this.overrideClearAlpha}setOverrideClearAlpha(e){this.overrideClearAlpha=e}render(e,t,n,a,s){const o=this.overrideClearColor,c=this.overrideClearAlpha,u=e.getClearAlpha(),d=o!==null,m=c>=0;d?(e.getClearColor(Un),e.setClearColor(o,m?c:u)):m&&e.setClearAlpha(c),e.setRenderTarget(this.renderToScreen?null:t),e.clear(this.color,this.depth,this.stencil),d?e.setClearColor(Un,u):m&&e.setClearAlpha(u)}},Fa=class extends De{constructor(e,t){super("MaskPass",e,t),this.needsSwap=!1,this.clearPass=new xr(!1,!1,!0),this.inverse=!1}set mainScene(e){this.scene=e}set mainCamera(e){this.camera=e}get inverted(){return this.inverse}set inverted(e){this.inverse=e}get clear(){return this.clearPass.enabled}set clear(e){this.clearPass.enabled=e}getClearPass(){return this.clearPass}isInverted(){return this.inverted}setInverted(e){this.inverted=e}render(e,t,n,a,s){const o=e.getContext(),c=e.state.buffers,u=this.scene,d=this.camera,m=this.clearPass,v=this.inverted?0:1,g=1-v;c.color.setMask(!1),c.depth.setMask(!1),c.color.setLocked(!0),c.depth.setLocked(!0),c.stencil.setTest(!0),c.stencil.setOp(o.REPLACE,o.REPLACE,o.REPLACE),c.stencil.setFunc(o.ALWAYS,v,4294967295),c.stencil.setClear(g),c.stencil.setLocked(!0),this.clearPass.enabled&&(this.renderToScreen?m.render(e,null):(m.render(e,t),m.render(e,n))),this.renderToScreen?(e.setRenderTarget(null),e.render(u,d)):(e.setRenderTarget(t),e.render(u,d),e.setRenderTarget(n),e.render(u,d)),c.color.setLocked(!1),c.depth.setLocked(!1),c.stencil.setLocked(!1),c.stencil.setFunc(o.EQUAL,1,4294967295),c.stencil.setOp(o.KEEP,o.KEEP,o.KEEP),c.stencil.setLocked(!0)}},Ua=class{constructor(t=null,{depthBuffer:n=!0,stencilBuffer:a=!1,multisampling:s=0,frameBufferType:o}={}){this.renderer=null,this.inputBuffer=this.createBuffer(n,a,o,s),this.outputBuffer=this.inputBuffer.clone(),this.copyPass=new Sr,this.depthTexture=null,this.passes=[],this.timer=new Da,this.autoRenderToScreen=!0,this.setRenderer(t)}get multisampling(){return this.inputBuffer.samples||0}set multisampling(t){const n=this.inputBuffer,a=this.multisampling;a>0&&t>0?(this.inputBuffer.samples=t,this.outputBuffer.samples=t,this.inputBuffer.dispose(),this.outputBuffer.dispose()):a!==t&&(this.inputBuffer.dispose(),this.outputBuffer.dispose(),this.inputBuffer=this.createBuffer(n.depthBuffer,n.stencilBuffer,n.texture.type,t),this.inputBuffer.depthTexture=this.depthTexture,this.outputBuffer=this.inputBuffer.clone())}getTimer(){return this.timer}getRenderer(){return this.renderer}setRenderer(t){if(this.renderer=t,t!==null){const n=t.getSize(new Ae),a=t.getContext().getContextAttributes().alpha,s=this.inputBuffer.texture.type;s===ct&&t.outputColorSpace===Ze&&(this.inputBuffer.texture.colorSpace=Ze,this.outputBuffer.texture.colorSpace=Ze,this.inputBuffer.dispose(),this.outputBuffer.dispose()),t.autoClear=!1,this.setSize(n.width,n.height);for(const o of this.passes)o.initialize(t,a,s)}}replaceRenderer(t,n=!0){const a=this.renderer,s=a.domElement.parentNode;return this.setRenderer(t),n&&s!==null&&(s.removeChild(a.domElement),s.appendChild(t.domElement)),a}createDepthTexture(){const t=this.depthTexture=new ui;return this.inputBuffer.depthTexture=t,this.inputBuffer.dispose(),this.inputBuffer.stencilBuffer?(t.format=di,t.type=hi):t.type=Jn,t}deleteDepthTexture(){if(this.depthTexture!==null){this.depthTexture.dispose(),this.depthTexture=null,this.inputBuffer.depthTexture=null,this.inputBuffer.dispose();for(const t of this.passes)t.setDepthTexture(null)}}createBuffer(t,n,a,s){const o=this.renderer,c=o===null?new Ae:o.getDrawingBufferSize(new Ae),u={minFilter:be,magFilter:be,stencilBuffer:n,depthBuffer:t,type:a},d=new Ge(c.width,c.height,u);return s>0&&(d.ignoreDepthForMultisampleCopy=!1,d.samples=s),a===ct&&o!==null&&o.outputColorSpace===Ze&&(d.texture.colorSpace=Ze),d.texture.name="EffectComposer.Buffer",d.texture.generateMipmaps=!1,d}setMainScene(t){for(const n of this.passes)n.mainScene=t}setMainCamera(t){for(const n of this.passes)n.mainCamera=t}addPass(t,n){const a=this.passes,s=this.renderer,o=s.getDrawingBufferSize(new Ae),c=s.getContext().getContextAttributes().alpha,u=this.inputBuffer.texture.type;if(t.setRenderer(s),t.setSize(o.width,o.height),t.initialize(s,c,u),this.autoRenderToScreen&&(a.length>0&&(a[a.length-1].renderToScreen=!1),t.renderToScreen&&(this.autoRenderToScreen=!1)),n!==void 0?a.splice(n,0,t):a.push(t),this.autoRenderToScreen&&(a[a.length-1].renderToScreen=!0),t.needsDepthTexture||this.depthTexture!==null)if(this.depthTexture===null){const d=this.createDepthTexture();for(t of a)t.setDepthTexture(d)}else t.setDepthTexture(this.depthTexture)}removePass(t){const n=this.passes,a=n.indexOf(t);if(a!==-1&&n.splice(a,1).length>0){if(this.depthTexture!==null){const c=(d,m)=>d||m.needsDepthTexture;n.reduce(c,!1)||(t.getDepthTexture()===this.depthTexture&&t.setDepthTexture(null),this.deleteDepthTexture())}this.autoRenderToScreen&&a===n.length&&(t.renderToScreen=!1,n.length>0&&(n[n.length-1].renderToScreen=!0))}}removeAllPasses(){const t=this.passes;this.deleteDepthTexture(),t.length>0&&(this.autoRenderToScreen&&(t[t.length-1].renderToScreen=!1),this.passes=[])}render(t){const n=this.renderer,a=this.copyPass;let s=this.inputBuffer,o=this.outputBuffer,c=!1,u,d,m;t===void 0&&(this.timer.update(),t=this.timer.getDelta());for(const v of this.passes)v.enabled&&(v.render(n,s,o,t,c),v.needsSwap&&(c&&(a.renderToScreen=v.renderToScreen,u=n.getContext(),d=n.state.buffers.stencil,d.setFunc(u.NOTEQUAL,1,4294967295),a.render(n,s,o,t,c),d.setFunc(u.EQUAL,1,4294967295)),m=s,s=o,o=m),v instanceof Fa?c=!0:v instanceof La&&(c=!1))}setSize(t,n,a){const s=this.renderer,o=s.getSize(new Ae);(t===void 0||n===void 0)&&(t=o.width,n=o.height),(o.width!==t||o.height!==n)&&s.setSize(t,n,a);const c=s.getDrawingBufferSize(new Ae);this.inputBuffer.setSize(c.width,c.height),this.outputBuffer.setSize(c.width,c.height);for(const u of this.passes)u.setSize(c.width,c.height)}reset(){this.dispose(),this.autoRenderToScreen=!0}dispose(){for(const t of this.passes)t.dispose();this.passes=[],this.inputBuffer!==null&&this.inputBuffer.dispose(),this.outputBuffer!==null&&this.outputBuffer.dispose(),this.deleteDepthTexture(),this.copyPass.dispose(),this.timer.dispose(),De.fullscreenGeometry.dispose()}},qe={NONE:0,DEPTH:1,CONVOLUTION:2},q={FRAGMENT_HEAD:"FRAGMENT_HEAD",FRAGMENT_MAIN_UV:"FRAGMENT_MAIN_UV",FRAGMENT_MAIN_IMAGE:"FRAGMENT_MAIN_IMAGE",VERTEX_HEAD:"VERTEX_HEAD",VERTEX_MAIN_SUPPORT:"VERTEX_MAIN_SUPPORT"},Ha=class{constructor(){this.shaderParts=new Map([[q.FRAGMENT_HEAD,null],[q.FRAGMENT_MAIN_UV,null],[q.FRAGMENT_MAIN_IMAGE,null],[q.VERTEX_HEAD,null],[q.VERTEX_MAIN_SUPPORT,null]]),this.defines=new Map,this.uniforms=new Map,this.blendModes=new Map,this.extensions=new Set,this.attributes=qe.NONE,this.varyings=new Set,this.uvTransformation=!1,this.readDepth=!1,this.colorSpace=Bt}},ln=!1,Hn=class{constructor(e=null){this.originalMaterials=new Map,this.material=null,this.materials=null,this.materialsBackSide=null,this.materialsDoubleSide=null,this.materialsFlatShaded=null,this.materialsFlatShadedBackSide=null,this.materialsFlatShadedDoubleSide=null,this.setMaterial(e),this.meshCount=0,this.replaceMaterial=t=>{if(t.isMesh){let n;if(t.material.flatShading)switch(t.material.side){case ft:n=this.materialsFlatShadedDoubleSide;break;case Zt:n=this.materialsFlatShadedBackSide;break;default:n=this.materialsFlatShaded;break}else switch(t.material.side){case ft:n=this.materialsDoubleSide;break;case Zt:n=this.materialsBackSide;break;default:n=this.materials;break}this.originalMaterials.set(t,t.material),t.isSkinnedMesh?t.material=n[2]:t.isInstancedMesh?t.material=n[1]:t.material=n[0],++this.meshCount}}}cloneMaterial(e){if(!(e instanceof tt))return e.clone();const t=e.uniforms,n=new Map;for(const s in t){const o=t[s].value;o.isRenderTargetTexture&&(t[s].value=null,n.set(s,o))}const a=e.clone();for(const s of n)t[s[0]].value=s[1],a.uniforms[s[0]].value=s[1];return a}setMaterial(e){if(this.disposeMaterials(),this.material=e,e!==null){const t=this.materials=[this.cloneMaterial(e),this.cloneMaterial(e),this.cloneMaterial(e)];for(const n of t)n.uniforms=Object.assign({},e.uniforms),n.side=mi;t[2].skinning=!0,this.materialsBackSide=t.map(n=>{const a=this.cloneMaterial(n);return a.uniforms=Object.assign({},e.uniforms),a.side=Zt,a}),this.materialsDoubleSide=t.map(n=>{const a=this.cloneMaterial(n);return a.uniforms=Object.assign({},e.uniforms),a.side=ft,a}),this.materialsFlatShaded=t.map(n=>{const a=this.cloneMaterial(n);return a.uniforms=Object.assign({},e.uniforms),a.flatShading=!0,a}),this.materialsFlatShadedBackSide=t.map(n=>{const a=this.cloneMaterial(n);return a.uniforms=Object.assign({},e.uniforms),a.flatShading=!0,a.side=Zt,a}),this.materialsFlatShadedDoubleSide=t.map(n=>{const a=this.cloneMaterial(n);return a.uniforms=Object.assign({},e.uniforms),a.flatShading=!0,a.side=ft,a})}}render(e,t,n){const a=e.shadowMap.enabled;if(e.shadowMap.enabled=!1,ln){const s=this.originalMaterials;this.meshCount=0,t.traverse(this.replaceMaterial),e.render(t,n);for(const o of s)o[0].material=o[1];this.meshCount!==s.size&&s.clear()}else{const s=t.overrideMaterial;t.overrideMaterial=this.material,e.render(t,n),t.overrideMaterial=s}e.shadowMap.enabled=a}disposeMaterials(){if(this.material!==null){const e=this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);for(const t of e)t.dispose()}}dispose(){this.originalMaterials.clear(),this.disposeMaterials()}static get workaroundEnabled(){return ln}static set workaroundEnabled(e){ln=e}},at=-1,Je=class extends gn{constructor(e,t=at,n=at,a=1){super(),this.resizable=e,this.baseSize=new Ae(1,1),this.preferredSize=new Ae(t,n),this.target=this.preferredSize,this.s=a,this.effectiveSize=new Ae,this.addEventListener("change",()=>this.updateEffectiveSize()),this.updateEffectiveSize()}updateEffectiveSize(){const e=this.baseSize,t=this.preferredSize,n=this.effectiveSize,a=this.scale;t.width!==at?n.width=t.width:t.height!==at?n.width=Math.round(t.height*(e.width/Math.max(e.height,1))):n.width=Math.round(e.width*a),t.height!==at?n.height=t.height:t.width!==at?n.height=Math.round(t.width/Math.max(e.width/Math.max(e.height,1),1)):n.height=Math.round(e.height*a)}get width(){return this.effectiveSize.width}set width(e){this.preferredWidth=e}get height(){return this.effectiveSize.height}set height(e){this.preferredHeight=e}getWidth(){return this.width}getHeight(){return this.height}get scale(){return this.s}set scale(e){this.s!==e&&(this.s=e,this.preferredSize.setScalar(at),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getScale(){return this.scale}setScale(e){this.scale=e}get baseWidth(){return this.baseSize.width}set baseWidth(e){this.baseSize.width!==e&&(this.baseSize.width=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseWidth(){return this.baseWidth}setBaseWidth(e){this.baseWidth=e}get baseHeight(){return this.baseSize.height}set baseHeight(e){this.baseSize.height!==e&&(this.baseSize.height=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseHeight(){return this.baseHeight}setBaseHeight(e){this.baseHeight=e}setBaseSize(e,t){(this.baseSize.width!==e||this.baseSize.height!==t)&&(this.baseSize.set(e,t),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}get preferredWidth(){return this.preferredSize.width}set preferredWidth(e){this.preferredSize.width!==e&&(this.preferredSize.width=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredWidth(){return this.preferredWidth}setPreferredWidth(e){this.preferredWidth=e}get preferredHeight(){return this.preferredSize.height}set preferredHeight(e){this.preferredSize.height!==e&&(this.preferredSize.height=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredHeight(){return this.preferredHeight}setPreferredHeight(e){this.preferredHeight=e}setPreferredSize(e,t){(this.preferredSize.width!==e||this.preferredSize.height!==t)&&(this.preferredSize.set(e,t),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}copy(e){this.s=e.scale,this.baseSize.set(e.baseWidth,e.baseHeight),this.preferredSize.set(e.preferredWidth,e.preferredHeight),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height)}static get AUTO_SIZE(){return at}},X={SKIP:9,SET:30,ADD:0,ALPHA:1,AVERAGE:2,COLOR:3,COLOR_BURN:4,COLOR_DODGE:5,DARKEN:6,DIFFERENCE:7,DIVIDE:8,DST:9,EXCLUSION:10,HARD_LIGHT:11,HARD_MIX:12,HUE:13,INVERT:14,INVERT_RGB:15,LIGHTEN:16,LINEAR_BURN:17,LINEAR_DODGE:18,LINEAR_LIGHT:19,LUMINOSITY:20,MULTIPLY:21,NEGATION:22,NORMAL:23,OVERLAY:24,PIN_LIGHT:25,REFLECT:26,SATURATION:27,SCREEN:28,SOFT_LIGHT:29,SRC:30,SUBTRACT:31,VIVID_LIGHT:32},za="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}",Ga="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}",ka="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}",Va="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",Wa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}",Za="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}",$a="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}",ja="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}",Xa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}",Ya="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}",Ka="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}",Qa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}",qa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}",Ja="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}",es="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}",ts="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}",ns="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}",rs="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}",is="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}",as="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",ss="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}",os="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}",ls="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}",cs="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}",us="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}",ds="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}",hs="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",fs="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}",ps="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}",ms="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}",vs="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}",gs="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}",Es=new Map([[X.ADD,za],[X.ALPHA,Ga],[X.AVERAGE,ka],[X.COLOR,Va],[X.COLOR_BURN,Wa],[X.COLOR_DODGE,Za],[X.DARKEN,$a],[X.DIFFERENCE,ja],[X.DIVIDE,Xa],[X.DST,null],[X.EXCLUSION,Ya],[X.HARD_LIGHT,Ka],[X.HARD_MIX,Qa],[X.HUE,qa],[X.INVERT,Ja],[X.INVERT_RGB,es],[X.LIGHTEN,ts],[X.LINEAR_BURN,ns],[X.LINEAR_DODGE,rs],[X.LINEAR_LIGHT,is],[X.LUMINOSITY,as],[X.MULTIPLY,ss],[X.NEGATION,os],[X.NORMAL,ls],[X.OVERLAY,cs],[X.PIN_LIGHT,us],[X.REFLECT,ds],[X.SATURATION,hs],[X.SCREEN,fs],[X.SOFT_LIGHT,ps],[X.SRC,ms],[X.SUBTRACT,vs],[X.VIVID_LIGHT,gs]]),Ss=class extends gn{constructor(e,t=1){super(),this._blendFunction=e,this.opacity=new ae(t)}getOpacity(){return this.opacity.value}setOpacity(e){this.opacity.value=e}get blendFunction(){return this._blendFunction}set blendFunction(e){this._blendFunction=e,this.dispatchEvent({type:"change"})}getBlendFunction(){return this.blendFunction}setBlendFunction(e){this.blendFunction=e}getShaderCode(){return Es.get(this.blendFunction)}},xs=`#include <common>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);l*=low*high;
#elif defined(THRESHOLD)
l=smoothstep(threshold,threshold+smoothing,l)*l;
#endif
#ifdef COLOR
gl_FragColor=vec4(texel.rgb*clamp(l,0.0,1.0),l);
#else
gl_FragColor=vec4(l);
#endif
}`,_s=class extends tt{constructor(e=!1,t=null){super({name:"LuminanceMaterial",defines:{THREE_REVISION:En.replace(/\D+/g,"")},uniforms:{inputBuffer:new ae(null),threshold:new ae(0),smoothing:new ae(1),range:new ae(null)},blending:gt,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:xs,vertexShader:Rn}),this.colorOutput=e,this.luminanceRange=t}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}get threshold(){return this.uniforms.threshold.value}set threshold(e){this.smoothing>0||e>0?this.defines.THRESHOLD="1":delete this.defines.THRESHOLD,this.uniforms.threshold.value=e}getThreshold(){return this.threshold}setThreshold(e){this.threshold=e}get smoothing(){return this.uniforms.smoothing.value}set smoothing(e){this.threshold>0||e>0?this.defines.THRESHOLD="1":delete this.defines.THRESHOLD,this.uniforms.smoothing.value=e}getSmoothingFactor(){return this.smoothing}setSmoothingFactor(e){this.smoothing=e}get useThreshold(){return this.threshold>0||this.smoothing>0}set useThreshold(e){}get colorOutput(){return this.defines.COLOR!==void 0}set colorOutput(e){e?this.defines.COLOR="1":delete this.defines.COLOR,this.needsUpdate=!0}isColorOutputEnabled(e){return this.colorOutput}setColorOutputEnabled(e){this.colorOutput=e}get useRange(){return this.luminanceRange!==null}set useRange(e){this.luminanceRange=null}get luminanceRange(){return this.uniforms.range.value}set luminanceRange(e){e!==null?this.defines.RANGE="1":delete this.defines.RANGE,this.uniforms.range.value=e,this.needsUpdate=!0}getLuminanceRange(){return this.luminanceRange}setLuminanceRange(e){this.luminanceRange=e}},ws=class extends De{constructor({renderTarget:e,luminanceRange:t,colorOutput:n,resolutionScale:a=1,width:s=Je.AUTO_SIZE,height:o=Je.AUTO_SIZE,resolutionX:c=s,resolutionY:u=o}={}){super("LuminancePass"),this.fullscreenMaterial=new _s(n,t),this.needsSwap=!1,this.renderTarget=e,this.renderTarget===void 0&&(this.renderTarget=new Ge(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="LuminancePass.Target");const d=this.resolution=new Je(this,c,u,a);d.addEventListener("change",m=>this.setSize(d.baseWidth,d.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}render(e,t,n,a,s){const o=this.fullscreenMaterial;o.inputBuffer=t.texture,e.setRenderTarget(this.renderToScreen?null:this.renderTarget),e.render(this.scene,this.camera)}setSize(e,t){const n=this.resolution;n.setBaseSize(e,t),this.renderTarget.setSize(n.width,n.height)}initialize(e,t,n){n!==void 0&&n!==ct&&(this.renderTarget.texture.type=n,this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}},fn=class extends gn{constructor(e,t,{attributes:n=qe.NONE,blendFunction:a=X.NORMAL,defines:s=new Map,uniforms:o=new Map,extensions:c=null,vertexShader:u=null}={}){super(),this.name=e,this.renderer=null,this.attributes=n,this.fragmentShader=t,this.vertexShader=u,this.defines=s,this.uniforms=o,this.extensions=c,this.blendMode=new Ss(a),this.blendMode.addEventListener("change",d=>this.setChanged()),this._inputColorSpace=Bt,this._outputColorSpace=nr}get inputColorSpace(){return this._inputColorSpace}set inputColorSpace(e){this._inputColorSpace=e,this.setChanged()}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e,this.setChanged()}set mainScene(e){}set mainCamera(e){}getName(){return this.name}setRenderer(e){this.renderer=e}getDefines(){return this.defines}getUniforms(){return this.uniforms}getExtensions(){return this.extensions}getBlendMode(){return this.blendMode}getAttributes(){return this.attributes}setAttributes(e){this.attributes=e,this.setChanged()}getFragmentShader(){return this.fragmentShader}setFragmentShader(e){this.fragmentShader=e,this.setChanged()}getVertexShader(){return this.vertexShader}setVertexShader(e){this.vertexShader=e,this.setChanged()}setChanged(){this.dispatchEvent({type:"change"})}setDepthTexture(e,t=Et){}update(e,t,n){}setSize(e,t){}initialize(e,t,n){}dispose(){for(const e of Object.keys(this)){const t=this[e];(t instanceof Ge||t instanceof ir||t instanceof ot||t instanceof De)&&this[e].dispose()}}},_r=class extends De{constructor(e,t,n=null){super("RenderPass",e,t),this.needsSwap=!1,this.clearPass=new xr,this.overrideMaterialManager=n===null?null:new Hn(n),this.ignoreBackground=!1,this.skipShadowMapUpdate=!1,this.selection=null}set mainScene(e){this.scene=e}set mainCamera(e){this.camera=e}get renderToScreen(){return super.renderToScreen}set renderToScreen(e){super.renderToScreen=e,this.clearPass.renderToScreen=e}get overrideMaterial(){const e=this.overrideMaterialManager;return e!==null?e.material:null}set overrideMaterial(e){const t=this.overrideMaterialManager;e!==null?t!==null?t.setMaterial(e):this.overrideMaterialManager=new Hn(e):t!==null&&(t.dispose(),this.overrideMaterialManager=null)}getOverrideMaterial(){return this.overrideMaterial}setOverrideMaterial(e){this.overrideMaterial=e}get clear(){return this.clearPass.enabled}set clear(e){this.clearPass.enabled=e}getSelection(){return this.selection}setSelection(e){this.selection=e}isBackgroundDisabled(){return this.ignoreBackground}setBackgroundDisabled(e){this.ignoreBackground=e}isShadowMapDisabled(){return this.skipShadowMapUpdate}setShadowMapDisabled(e){this.skipShadowMapUpdate=e}getClearPass(){return this.clearPass}render(e,t,n,a,s){const o=this.scene,c=this.camera,u=this.selection,d=c.layers.mask,m=o.background,v=e.shadowMap.autoUpdate,g=this.renderToScreen?null:t;u!==null&&c.layers.set(u.getLayer()),this.skipShadowMapUpdate&&(e.shadowMap.autoUpdate=!1),(this.ignoreBackground||this.clearPass.overrideClearColor!==null)&&(o.background=null),this.clearPass.enabled&&this.clearPass.render(e,t),e.setRenderTarget(g),this.overrideMaterialManager!==null?this.overrideMaterialManager.render(e,o,c):e.render(o,c),c.layers.mask=d,o.background=m,e.shadowMap.autoUpdate=v}},Ce={LINEAR:0,REINHARD:1,REINHARD2:2,REINHARD2_ADAPTIVE:3,UNCHARTED2:4,OPTIMIZED_CINEON:5,CINEON:5,ACES_FILMIC:6,AGX:7,NEUTRAL:8},Ms=`#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
#ifdef DOWNSAMPLE_NORMALS
uniform lowp sampler2D normalBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);
#ifdef DOWNSAMPLE_NORMALS
vec3 n[4];n[0]=texture2D(normalBuffer,vUv0).rgb;n[1]=texture2D(normalBuffer,vUv1).rgb;n[2]=texture2D(normalBuffer,vUv2).rgb;n[3]=texture2D(normalBuffer,vUv3).rgb;
#else
vec3 n[4];n[0]=vec3(0.0);n[1]=vec3(0.0);n[2]=vec3(0.0);n[3]=vec3(0.0);
#endif
gl_FragColor=vec4(n[index],d[index]);}`,ys="uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}",Ts=class extends tt{constructor(){super({name:"DepthDownsamplingMaterial",defines:{DEPTH_PACKING:"0"},uniforms:{depthBuffer:new ae(null),normalBuffer:new ae(null),texelSize:new ae(new Ae)},blending:gt,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:Ms,vertexShader:ys})}set depthBuffer(e){this.uniforms.depthBuffer.value=e}set depthPacking(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}setDepthBuffer(e,t=Et){this.depthBuffer=e,this.depthPacking=t}set normalBuffer(e){this.uniforms.normalBuffer.value=e,e!==null?this.defines.DOWNSAMPLE_NORMALS="1":delete this.defines.DOWNSAMPLE_NORMALS,this.needsUpdate=!0}setNormalBuffer(e){this.normalBuffer=e}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t)}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}},bs=class extends De{constructor({normalBuffer:e=null,resolutionScale:t=.5,width:n=Je.AUTO_SIZE,height:a=Je.AUTO_SIZE,resolutionX:s=n,resolutionY:o=a}={}){super("DepthDownsamplingPass");const c=new Ts;c.normalBuffer=e,this.fullscreenMaterial=c,this.needsDepthTexture=!0,this.needsSwap=!1,this.renderTarget=new Ge(1,1,{minFilter:vt,magFilter:vt,depthBuffer:!1,type:$e}),this.renderTarget.texture.name="DepthDownsamplingPass.Target",this.renderTarget.texture.generateMipmaps=!1;const u=this.resolution=new Je(this,s,o,t);u.addEventListener("change",d=>this.setSize(u.baseWidth,u.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}setDepthTexture(e,t=Et){this.fullscreenMaterial.depthBuffer=e,this.fullscreenMaterial.depthPacking=t}render(e,t,n,a,s){e.setRenderTarget(this.renderToScreen?null:this.renderTarget),e.render(this.scene,this.camera)}setSize(e,t){const n=this.resolution;n.setBaseSize(e,t),this.renderTarget.setSize(n.width,n.height),this.fullscreenMaterial.setSize(e,t)}initialize(e,t,n){const a=e.getContext();if(!(a.getExtension("EXT_color_buffer_float")||a.getExtension("EXT_color_buffer_half_float")))throw new Error("Rendering to float texture is not supported.")}},Rs=`#include <packing>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
uniform lowp sampler2D luminanceBuffer0;uniform lowp sampler2D luminanceBuffer1;uniform float minLuminance;uniform float deltaTime;uniform float tau;varying vec2 vUv;void main(){float l0=unpackRGBAToFloat(texture2D(luminanceBuffer0,vUv));
#if __VERSION__ < 300
float l1=texture2DLodEXT(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;
#else
float l1=textureLod(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;
#endif
l0=max(minLuminance,l0);l1=max(minLuminance,l1);float adaptedLum=l0+(l1-l0)*(1.0-exp(-deltaTime*tau));gl_FragColor=(adaptedLum==1.0)?vec4(1.0):packFloatToRGBA(adaptedLum);}`,Cs=class extends tt{constructor(){super({name:"AdaptiveLuminanceMaterial",defines:{MIP_LEVEL_1X1:"0.0"},uniforms:{luminanceBuffer0:new ae(null),luminanceBuffer1:new ae(null),minLuminance:new ae(.01),deltaTime:new ae(0),tau:new ae(1)},extensions:{shaderTextureLOD:!0},blending:gt,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:Rs,vertexShader:Rn})}set luminanceBuffer0(e){this.uniforms.luminanceBuffer0.value=e}setLuminanceBuffer0(e){this.uniforms.luminanceBuffer0.value=e}set luminanceBuffer1(e){this.uniforms.luminanceBuffer1.value=e}setLuminanceBuffer1(e){this.uniforms.luminanceBuffer1.value=e}set mipLevel1x1(e){this.defines.MIP_LEVEL_1X1=e.toFixed(1),this.needsUpdate=!0}setMipLevel1x1(e){this.mipLevel1x1=e}set deltaTime(e){this.uniforms.deltaTime.value=e}setDeltaTime(e){this.uniforms.deltaTime.value=e}get minLuminance(){return this.uniforms.minLuminance.value}set minLuminance(e){this.uniforms.minLuminance.value=e}getMinLuminance(){return this.uniforms.minLuminance.value}setMinLuminance(e){this.uniforms.minLuminance.value=e}get adaptationRate(){return this.uniforms.tau.value}set adaptationRate(e){this.uniforms.tau.value=e}getAdaptationRate(){return this.uniforms.tau.value}setAdaptationRate(e){this.uniforms.tau.value=e}},As=class extends De{constructor(e,{minLuminance:t=.01,adaptationRate:n=1}={}){super("AdaptiveLuminancePass"),this.fullscreenMaterial=new Cs,this.needsSwap=!1,this.renderTargetPrevious=new Ge(1,1,{minFilter:vt,magFilter:vt,depthBuffer:!1}),this.renderTargetPrevious.texture.name="Luminance.Previous";const a=this.fullscreenMaterial;a.luminanceBuffer0=this.renderTargetPrevious.texture,a.luminanceBuffer1=e,a.minLuminance=t,a.adaptationRate=n,this.renderTargetAdapted=this.renderTargetPrevious.clone(),this.renderTargetAdapted.texture.name="Luminance.Adapted",this.copyPass=new Sr(this.renderTargetPrevious,!1)}get texture(){return this.renderTargetAdapted.texture}getTexture(){return this.renderTargetAdapted.texture}set mipLevel1x1(e){this.fullscreenMaterial.mipLevel1x1=e}get adaptationRate(){return this.fullscreenMaterial.adaptationRate}set adaptationRate(e){this.fullscreenMaterial.adaptationRate=e}render(e,t,n,a,s){this.fullscreenMaterial.deltaTime=a,e.setRenderTarget(this.renderToScreen?null:this.renderTargetAdapted),e.render(this.scene,this.camera),this.copyPass.render(e,this.renderTargetAdapted)}},Is=`#include <tonemapping_pars_fragment>
uniform float whitePoint;
#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3
uniform float middleGrey;
#if TONE_MAPPING_MODE == 3
uniform lowp sampler2D luminanceBuffer;
#else
uniform float averageLuminance;
#endif
vec3 Reinhard2ToneMapping(vec3 color){color*=toneMappingExposure;float l=luminance(color);
#if TONE_MAPPING_MODE == 3
float lumAvg=unpackRGBAToFloat(texture2D(luminanceBuffer,vec2(0.5)));
#else
float lumAvg=averageLuminance;
#endif
float lumScaled=(l*middleGrey)/max(lumAvg,1e-6);float lumCompressed=lumScaled*(1.0+lumScaled/(whitePoint*whitePoint));lumCompressed/=(1.0+lumScaled);return clamp(lumCompressed*color,0.0,1.0);}
#elif TONE_MAPPING_MODE == 4
#define A 0.15
#define B 0.50
#define C 0.10
#define D 0.20
#define E 0.02
#define F 0.30
vec3 Uncharted2Helper(const in vec3 x){return((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}vec3 Uncharted2ToneMapping(vec3 color){color*=toneMappingExposure;return clamp(Uncharted2Helper(color)/Uncharted2Helper(vec3(whitePoint)),0.0,1.0);}
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){
#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3
outputColor=vec4(Reinhard2ToneMapping(inputColor.rgb),inputColor.a);
#elif TONE_MAPPING_MODE == 4
outputColor=vec4(Uncharted2ToneMapping(inputColor.rgb),inputColor.a);
#else
outputColor=vec4(toneMapping(inputColor.rgb),inputColor.a);
#endif
}`,Ps=class extends fn{constructor({blendFunction:e=X.SRC,adaptive:t=!1,mode:n=t?Ce.REINHARD2_ADAPTIVE:Ce.AGX,resolution:a=256,maxLuminance:s=4,whitePoint:o=s,middleGrey:c=.6,minLuminance:u=.01,averageLuminance:d=1,adaptationRate:m=1}={}){super("ToneMappingEffect",Is,{blendFunction:e,uniforms:new Map([["luminanceBuffer",new ae(null)],["maxLuminance",new ae(s)],["whitePoint",new ae(o)],["middleGrey",new ae(c)],["averageLuminance",new ae(d)]])}),this.renderTargetLuminance=new Ge(1,1,{minFilter:vi,depthBuffer:!1}),this.renderTargetLuminance.texture.generateMipmaps=!0,this.renderTargetLuminance.texture.name="Luminance",this.luminancePass=new ws({renderTarget:this.renderTargetLuminance}),this.adaptiveLuminancePass=new As(this.luminancePass.texture,{minLuminance:u,adaptationRate:m}),this.uniforms.get("luminanceBuffer").value=this.adaptiveLuminancePass.texture,this.resolution=a,this.mode=n}get mode(){return Number(this.defines.get("TONE_MAPPING_MODE"))}set mode(e){if(this.mode===e)return;const n=En.replace(/\D+/g,"")>=168?"CineonToneMapping(texel)":"OptimizedCineonToneMapping(texel)";switch(this.defines.clear(),this.defines.set("TONE_MAPPING_MODE",e.toFixed(0)),e){case Ce.LINEAR:this.defines.set("toneMapping(texel)","LinearToneMapping(texel)");break;case Ce.REINHARD:this.defines.set("toneMapping(texel)","ReinhardToneMapping(texel)");break;case Ce.CINEON:case Ce.OPTIMIZED_CINEON:this.defines.set("toneMapping(texel)",n);break;case Ce.ACES_FILMIC:this.defines.set("toneMapping(texel)","ACESFilmicToneMapping(texel)");break;case Ce.AGX:this.defines.set("toneMapping(texel)","AgXToneMapping(texel)");break;case Ce.NEUTRAL:this.defines.set("toneMapping(texel)","NeutralToneMapping(texel)");break;default:this.defines.set("toneMapping(texel)","texel");break}this.adaptiveLuminancePass.enabled=e===Ce.REINHARD2_ADAPTIVE,this.setChanged()}getMode(){return this.mode}setMode(e){this.mode=e}get whitePoint(){return this.uniforms.get("whitePoint").value}set whitePoint(e){this.uniforms.get("whitePoint").value=e}get middleGrey(){return this.uniforms.get("middleGrey").value}set middleGrey(e){this.uniforms.get("middleGrey").value=e}get averageLuminance(){return this.uniforms.get("averageLuminance").value}set averageLuminance(e){this.uniforms.get("averageLuminance").value=e}get adaptiveLuminanceMaterial(){return this.adaptiveLuminancePass.fullscreenMaterial}getAdaptiveLuminanceMaterial(){return this.adaptiveLuminanceMaterial}get resolution(){return this.luminancePass.resolution.width}set resolution(e){const t=Math.max(0,Math.ceil(Math.log2(e))),n=Math.pow(2,t);this.luminancePass.resolution.setPreferredSize(n,n),this.adaptiveLuminanceMaterial.mipLevel1x1=t}getResolution(){return this.resolution}setResolution(e){this.resolution=e}get adaptive(){return this.mode===Ce.REINHARD2_ADAPTIVE}set adaptive(e){this.mode=e?Ce.REINHARD2_ADAPTIVE:Ce.REINHARD2}get adaptationRate(){return this.adaptiveLuminanceMaterial.adaptationRate}set adaptationRate(e){this.adaptiveLuminanceMaterial.adaptationRate=e}get distinction(){return console.warn(this.name,"distinction was removed."),1}set distinction(e){console.warn(this.name,"distinction was removed.")}update(e,t,n){this.adaptiveLuminancePass.enabled&&(this.luminancePass.render(e,t),this.adaptiveLuminancePass.render(e,null,null,n))}initialize(e,t,n){this.adaptiveLuminancePass.initialize(e,t,n)}},Ds=`#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
}`,Bs="uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}",Ls=class extends tt{constructor(e,t,n,a,s=!1){super({name:"EffectMaterial",defines:{THREE_REVISION:En.replace(/\D+/g,""),DEPTH_PACKING:"0",ENCODE_OUTPUT:"1"},uniforms:{inputBuffer:new ae(null),depthBuffer:new ae(null),resolution:new ae(new Ae),texelSize:new ae(new Ae),cameraNear:new ae(.3),cameraFar:new ae(1e3),aspect:new ae(1),time:new ae(0)},blending:gt,toneMapped:!1,depthWrite:!1,depthTest:!1,dithering:s}),e&&this.setShaderParts(e),t&&this.setDefines(t),n&&this.setUniforms(n),this.copyCameraSettings(a)}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}get depthBuffer(){return this.uniforms.depthBuffer.value}set depthBuffer(e){this.uniforms.depthBuffer.value=e}get depthPacking(){return Number(this.defines.DEPTH_PACKING)}set depthPacking(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}setDepthBuffer(e,t=Et){this.depthBuffer=e,this.depthPacking=t}setShaderData(e){this.setShaderParts(e.shaderParts),this.setDefines(e.defines),this.setUniforms(e.uniforms),this.setExtensions(e.extensions)}setShaderParts(e){return this.fragmentShader=Ds.replace(q.FRAGMENT_HEAD,e.get(q.FRAGMENT_HEAD)||"").replace(q.FRAGMENT_MAIN_UV,e.get(q.FRAGMENT_MAIN_UV)||"").replace(q.FRAGMENT_MAIN_IMAGE,e.get(q.FRAGMENT_MAIN_IMAGE)||""),this.vertexShader=Bs.replace(q.VERTEX_HEAD,e.get(q.VERTEX_HEAD)||"").replace(q.VERTEX_MAIN_SUPPORT,e.get(q.VERTEX_MAIN_SUPPORT)||""),this.needsUpdate=!0,this}setDefines(e){for(const t of e.entries())this.defines[t[0]]=t[1];return this.needsUpdate=!0,this}setUniforms(e){for(const t of e.entries())this.uniforms[t[0]]=t[1];return this}setExtensions(e){this.extensions={};for(const t of e)this.extensions[t]=!0;return this}get encodeOutput(){return this.defines.ENCODE_OUTPUT!==void 0}set encodeOutput(e){this.encodeOutput!==e&&(e?this.defines.ENCODE_OUTPUT="1":delete this.defines.ENCODE_OUTPUT,this.needsUpdate=!0)}isOutputEncodingEnabled(e){return this.encodeOutput}setOutputEncodingEnabled(e){this.encodeOutput=e}get time(){return this.uniforms.time.value}set time(e){this.uniforms.time.value=e}setDeltaTime(e){this.uniforms.time.value+=e}adoptCameraSettings(e){this.copyCameraSettings(e)}copyCameraSettings(e){e&&(this.uniforms.cameraNear.value=e.near,this.uniforms.cameraFar.value=e.far,e instanceof vn?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}setSize(e,t){const n=this.uniforms;n.resolution.value.set(e,t),n.texelSize.value.set(1/e,1/t),n.aspect.value=e/t}static get Section(){return q}};function zn(e,t,n){for(const a of t){const s="$1"+e+a.charAt(0).toUpperCase()+a.slice(1),o=new RegExp("([^\\.])(\\b"+a+"\\b)","g");for(const c of n.entries())c[1]!==null&&n.set(c[0],c[1].replace(o,s))}}function Ns(e,t,n){let a=t.getFragmentShader(),s=t.getVertexShader();const o=a!==void 0&&/mainImage/.test(a),c=a!==void 0&&/mainUv/.test(a);if(n.attributes|=t.getAttributes(),a===void 0)throw new Error(`Missing fragment shader (${t.name})`);if(c&&n.attributes&qe.CONVOLUTION)throw new Error(`Effects that transform UVs are incompatible with convolution effects (${t.name})`);if(!o&&!c)throw new Error(`Could not find mainImage or mainUv function (${t.name})`);{const u=/\w+\s+(\w+)\([\w\s,]*\)\s*{/g,d=n.shaderParts;let m=d.get(q.FRAGMENT_HEAD)||"",v=d.get(q.FRAGMENT_MAIN_UV)||"",g=d.get(q.FRAGMENT_MAIN_IMAGE)||"",R=d.get(q.VERTEX_HEAD)||"",I=d.get(q.VERTEX_MAIN_SUPPORT)||"";const Z=new Set,Y=new Set;if(c&&(v+=`	${e}MainUv(UV);
`,n.uvTransformation=!0),s!==null&&/mainSupport/.test(s)){const L=/mainSupport *\([\w\s]*?uv\s*?\)/.test(s);I+=`	${e}MainSupport(`,I+=L?`vUv);
`:`);
`;for(const D of s.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))for(const K of D[1].split(/\s*,\s*/))n.varyings.add(K),Z.add(K),Y.add(K);for(const D of s.matchAll(u))Y.add(D[1])}for(const L of a.matchAll(u))Y.add(L[1]);for(const L of t.defines.keys())Y.add(L.replace(/\([\w\s,]*\)/g,""));for(const L of t.uniforms.keys())Y.add(L);Y.delete("while"),Y.delete("for"),Y.delete("if"),t.uniforms.forEach((L,D)=>n.uniforms.set(e+D.charAt(0).toUpperCase()+D.slice(1),L)),t.defines.forEach((L,D)=>n.defines.set(e+D.charAt(0).toUpperCase()+D.slice(1),L));const H=new Map([["fragment",a],["vertex",s]]);zn(e,Y,n.defines),zn(e,Y,H),a=H.get("fragment"),s=H.get("vertex");const k=t.blendMode;if(n.blendModes.set(k.blendFunction,k),o){t.inputColorSpace!==null&&t.inputColorSpace!==n.colorSpace&&(g+=t.inputColorSpace===Ze?`color0 = sRGBTransferOETF(color0);
	`:`color0 = sRGBToLinear(color0);
	`),t.outputColorSpace!==nr?n.colorSpace=t.outputColorSpace:t.inputColorSpace!==null&&(n.colorSpace=t.inputColorSpace);const L=/MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;g+=`${e}MainImage(color0, UV, `,n.attributes&qe.DEPTH&&L.test(a)&&(g+="depth, ",n.readDepth=!0),g+=`color1);
	`;const D=e+"BlendOpacity";n.uniforms.set(D,k.opacity),g+=`color0 = blend${k.blendFunction}(color0, color1, ${D});

	`,m+=`uniform float ${D};

`}if(m+=a+`
`,s!==null&&(R+=s+`
`),d.set(q.FRAGMENT_HEAD,m),d.set(q.FRAGMENT_MAIN_UV,v),d.set(q.FRAGMENT_MAIN_IMAGE,g),d.set(q.VERTEX_HEAD,R),d.set(q.VERTEX_MAIN_SUPPORT,I),t.extensions!==null)for(const L of t.extensions)n.extensions.add(L)}}var Os=class extends De{constructor(e,...t){super("EffectPass"),this.fullscreenMaterial=new Ls(null,null,null,e),this.listener=n=>this.handleEvent(n),this.effects=[],this.setEffects(t),this.skipRendering=!1,this.minTime=1,this.maxTime=Number.POSITIVE_INFINITY,this.timeScale=1}set mainScene(e){for(const t of this.effects)t.mainScene=e}set mainCamera(e){this.fullscreenMaterial.copyCameraSettings(e);for(const t of this.effects)t.mainCamera=e}get encodeOutput(){return this.fullscreenMaterial.encodeOutput}set encodeOutput(e){this.fullscreenMaterial.encodeOutput=e}get dithering(){return this.fullscreenMaterial.dithering}set dithering(e){const t=this.fullscreenMaterial;t.dithering=e,t.needsUpdate=!0}setEffects(e){for(const t of this.effects)t.removeEventListener("change",this.listener);this.effects=e.sort((t,n)=>n.attributes-t.attributes);for(const t of this.effects)t.addEventListener("change",this.listener)}updateMaterial(){const e=new Ha;let t=0;for(const c of this.effects)if(c.blendMode.blendFunction===X.DST)e.attributes|=c.getAttributes()&qe.DEPTH;else{if(e.attributes&c.getAttributes()&qe.CONVOLUTION)throw new Error(`Convolution effects cannot be merged (${c.name})`);Ns("e"+t++,c,e)}let n=e.shaderParts.get(q.FRAGMENT_HEAD),a=e.shaderParts.get(q.FRAGMENT_MAIN_IMAGE),s=e.shaderParts.get(q.FRAGMENT_MAIN_UV);const o=/\bblend\b/g;for(const c of e.blendModes.values())n+=c.getShaderCode().replace(o,`blend${c.blendFunction}`)+`
`;e.attributes&qe.DEPTH?(e.readDepth&&(a=`float depth = readDepth(UV);

	`+a),this.needsDepthTexture=this.getDepthTexture()===null):this.needsDepthTexture=!1,e.colorSpace===Ze&&(a+=`color0 = sRGBToLinear(color0);
	`),e.uvTransformation?(s=`vec2 transformedUv = vUv;
`+s,e.defines.set("UV","transformedUv")):e.defines.set("UV","vUv"),e.shaderParts.set(q.FRAGMENT_HEAD,n),e.shaderParts.set(q.FRAGMENT_MAIN_IMAGE,a),e.shaderParts.set(q.FRAGMENT_MAIN_UV,s);for(const[c,u]of e.shaderParts)u!==null&&e.shaderParts.set(c,u.trim().replace(/^#/,`
#`));this.skipRendering=t===0,this.needsSwap=!this.skipRendering,this.fullscreenMaterial.setShaderData(e)}recompile(){this.updateMaterial()}getDepthTexture(){return this.fullscreenMaterial.depthBuffer}setDepthTexture(e,t=Et){this.fullscreenMaterial.depthBuffer=e,this.fullscreenMaterial.depthPacking=t;for(const n of this.effects)n.setDepthTexture(e,t)}render(e,t,n,a,s){for(const o of this.effects)o.update(e,t,a);if(!this.skipRendering||this.renderToScreen){const o=this.fullscreenMaterial;o.inputBuffer=t.texture,o.time+=a*this.timeScale,e.setRenderTarget(this.renderToScreen?null:n),e.render(this.scene,this.camera)}}setSize(e,t){this.fullscreenMaterial.setSize(e,t);for(const n of this.effects)n.setSize(e,t)}initialize(e,t,n){this.renderer=e;for(const a of this.effects)a.initialize(e,t,n);this.updateMaterial(),n!==void 0&&n!==ct&&(this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}dispose(){super.dispose();for(const e of this.effects)e.removeEventListener("change",this.listener),e.dispose()}handleEvent(e){switch(e.type){case"change":this.recompile();break}}},Fs=class extends De{constructor(e,t,{renderTarget:n,resolutionScale:a=1,width:s=Je.AUTO_SIZE,height:o=Je.AUTO_SIZE,resolutionX:c=s,resolutionY:u=o}={}){super("NormalPass"),this.needsSwap=!1,this.renderPass=new _r(e,t,new fi);const d=this.renderPass;d.ignoreBackground=!0,d.skipShadowMapUpdate=!0;const m=d.getClearPass();m.overrideClearColor=new rr(7829503),m.overrideClearAlpha=1,this.renderTarget=n,this.renderTarget===void 0&&(this.renderTarget=new Ge(1,1,{minFilter:vt,magFilter:vt}),this.renderTarget.texture.name="NormalPass.Target");const v=this.resolution=new Je(this,c,u,a);v.addEventListener("change",g=>this.setSize(v.baseWidth,v.baseHeight))}set mainScene(e){this.renderPass.mainScene=e}set mainCamera(e){this.renderPass.mainCamera=e}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}getResolutionScale(){return this.resolution.scale}setResolutionScale(e){this.resolution.scale=e}render(e,t,n,a,s){const o=this.renderToScreen?null:this.renderTarget;this.renderPass.render(e,o,o)}setSize(e,t){const n=this.resolution;n.setBaseSize(e,t),this.renderTarget.setSize(n.width,n.height)}};const Us=b.createContext(null),Gn=e=>(e.getAttributes()&qe.CONVOLUTION)===qe.CONVOLUTION,Ys=Pt.memo(b.forwardRef(({children:e,camera:t,scene:n,resolutionScale:a,enabled:s=!0,renderPriority:o=1,autoClear:c=!0,depthBuffer:u,enableNormalPass:d,stencilBuffer:m,multisampling:v=8,frameBufferType:g=Pe},R)=>{const{gl:I,scene:Z,camera:Y,size:H}=et(),k=n||Z,L=t||Y,[D,K,V]=b.useMemo(()=>{const _=Ki(),S=new Ua(I,{depthBuffer:u,stencilBuffer:m,multisampling:v>0&&_?v:0,frameBufferType:g});S.addPass(new _r(k,L));let U=null,P=null;return d&&(P=new Fs(k,L),P.enabled=!1,S.addPass(P),a!==void 0&&_&&(U=new bs({normalBuffer:P.texture,resolutionScale:a}),U.enabled=!1,S.addPass(U))),[S,P,U]},[L,I,u,m,v,g,k,d,a]);b.useEffect(()=>D==null?void 0:D.setSize(H.width,H.height),[D,H]),pn((_,S)=>{if(s){const U=I.autoClear;I.autoClear=c,m&&!c&&I.clearStencil(),D.render(S),I.autoClear=U}},s?o:0);const O=b.useRef(null);b.useLayoutEffect(()=>{var _;const S=[],U=(_=O.current)==null?void 0:_.__r3f;if(U&&D){const P=U.objects;for(let z=0;z<P.length;z++){const $=P[z];if($ instanceof fn){const N=[$];if(!Gn($)){let F=null;for(;(F=P[z+1])instanceof fn&&!Gn(F);)N.push(F),z++}const W=new Os(L,...N);S.push(W)}else $ instanceof De&&S.push($)}for(const z of S)D==null||D.addPass(z);K&&(K.enabled=!0),V&&(V.enabled=!0)}return()=>{for(const P of S)D==null||D.removePass(P);K&&(K.enabled=!1),V&&(V.enabled=!1)}},[D,e,L,K,V]),b.useEffect(()=>{const _=I.toneMapping;return I.toneMapping=Ei,()=>{I.toneMapping=_}},[I]);const ne=b.useMemo(()=>({composer:D,normalPass:K,downSamplingPass:V,resolutionScale:a,camera:L,scene:k}),[D,K,V,a,L,k]);return b.useImperativeHandle(R,()=>D,[D]),Ie.jsx(Us.Provider,{value:ne,children:Ie.jsx("group",{ref:O,children:e})})}));let Hs=0;const kn=new WeakMap,zs=(e,t)=>Pt.forwardRef(function({blendFunction:a=void 0,opacity:s=void 0,...o},c){let u=kn.get(e);if(!u){const v=`@react-three/postprocessing/${e.name}-${Hs++}`;tr({[v]:e}),kn.set(e,u=v)}const d=et(v=>v.camera),m=Pt.useMemo(()=>{var v,g;return[...(v=void 0)!=null?v:[],...(g=o.args)!=null?g:[{...t,...o}]]},[JSON.stringify(o)]);return Ie.jsx(u,{camera:d,"blendMode-blendFunction":a,"blendMode-opacity-value":s,...o,ref:c,args:m})}),Ks=zs(Ps),wr=b.createContext(void 0),Qs=({initialPoi:e,children:t})=>{const[n,a]=b.useState(e),[s,o]=b.useState(null),c=u=>{o(n),a(u)};return Ie.jsx(wr.Provider,{value:{activePoi:n,previousPoi:s,setActivePoi:c},children:t})},qs=()=>{const e=b.useContext(wr);if(!e)throw new Error("usePOI must be used within a POIProvider");return e},Js=()=>{const{progress:e}=Yi();return Ie.jsx(Wi,{center:!0,children:Ie.jsxs($r,{display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",children:[Ie.jsx(Si,{size:80,thickness:4}),Ie.jsxs(jr,{variant:"h6",color:"textPrimary",mt:2,children:[Math.round(e),"% Loaded"]})]})})},eo=({modelData:e})=>Ie.jsx("group",{dispose:null,children:e.map((t,n)=>Ie.jsx(Gs,{...t},n))});function Gs(e){const t=Xr+e.path,{scene:n}=xi(t),a=b.useMemo(()=>{const s=new _i;return s.position.copy(n.position),s.rotation.copy(n.rotation),s.scale.copy(n.scale),n.position.set(0,0,0),n.rotation.set(0,0,0),n.scale.set(1,1,1),s.add(n),s},[n]);return b.useEffect(()=>{n.traverse(s=>{s.isMesh&&(s.castShadow=!0,s.receiveShadow=!0)})},[n]),Ie.jsx("primitive",{object:a,dispose:null})}const to=({cameraSettings:e,debugSettings:t})=>{const{scene:n}=et();let a=n.getObjectByName("cameraFocusObject");if(!a){if(a=new wi,a.name="cameraFocusObject",e!=null&&e.lookAt&&a.position.set(e.lookAt.x,e.lookAt.y,e.lookAt.z),t!=null&&t.allTrue){const s=new Mi(.05,32,32),o=new er({color:16711680}),c=new Nt(s,o);a.add(c)}n.add(a)}return null};export{to as A,Ws as C,js as E,Js as L,Qs as P,Ks as T,Ys as a,Zs as b,eo as c,De as d,qs as e,$s as u};
