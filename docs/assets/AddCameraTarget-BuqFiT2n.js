import{g as Zr,e as $r,f as jr,r as R,h as Xr,j as Ae,i as Yr,k as Kr,c as Gn,_ as qr,m as Dt,B as Vn,T as Wn,s as Zn}from"./index-C7JdVwin.js";import{am as $n,u as ze,g as mr,$ as ft,m as Qe,O as vr,a1 as gr,V as Ie,an as Zt,M as Lt,ao as jn,S as tt,ap as Qr,aq as Jr,H as Be,F as je,ar as pt,L as Re,aa as Nt,k as Xn,J as $t,as as st,d as qt,P as en,W as Ge,at as Qt,au as Yn,a7 as Kn,av as Pt,K as ot,aw as qn,ax as Qn,ay as Jn,az as tn,aA as ct,i as rn,aB as Kt,aC as ei,aD as ti,aE as Dr,aF as $e,aG as gt,aH as Jt,aI as ri,aJ as ni,aK as ii,aL as ai,f as si,h as nn,ab as Nr,D as oi,aM as li,aN as ci,aO as Er,a8 as an,aP as Et,N as vt,aQ as ui,C as sn,aR as di,aS as jt,aT as hi,aU as re,aV as on,j as fi,R as Sr,v as pi,a6 as Pr,aW as mi,ak as vi,l as gi,G as Ei,e as Si,ah as xi}from"./HamburgerMenu-CkIyDhNY.js";function _i(e){return $r("MuiCard",e)}Zr("MuiCard",["root"]);const wi=e=>{const{classes:t}=e;return Kr({root:["root"]},_i,t)},Ti=jr($n,{name:"MuiCard",slot:"Root",overridesResolver:(e,t)=>t.root})({overflow:"hidden"}),Us=R.forwardRef(function(t,r){const a=Xr({props:t,name:"MuiCard"}),{className:s,raised:o=!1,...l}=a,u={...a,raised:o},d=wi(u);return Ae.jsx(Ti,{className:Yr(d.root,s),elevation:o?8:void 0,ref:r,ownerState:u,...l})});function Mi(e){return $r("MuiCardContent",e)}Zr("MuiCardContent",["root"]);const yi=e=>{const{classes:t}=e;return Kr({root:["root"]},Mi,t)},Ri=jr("div",{name:"MuiCardContent",slot:"Root",overridesResolver:(e,t)=>t.root})({padding:16,"&:last-child":{paddingBottom:24}}),zs=R.forwardRef(function(t,r){const a=Xr({props:t,name:"MuiCardContent"}),{className:s,component:o="div",...l}=a,u={...a,component:o},d=yi(u);return Ae.jsx(Ri,{as:o,className:Yr(d.root,s),ownerState:u,ref:r,...l})}),Ft=new Qe,xr=new Qe,bi=new Qe,Or=new Ie;function Ci(e,t,r){const a=Ft.setFromMatrixPosition(e.matrixWorld);a.project(t);const s=r.width/2,o=r.height/2;return[a.x*s+s,-(a.y*o)+o]}function Ii(e,t){const r=Ft.setFromMatrixPosition(e.matrixWorld),a=xr.setFromMatrixPosition(t.matrixWorld),s=r.sub(a),o=t.getWorldDirection(bi);return s.angleTo(o)>Math.PI/2}function Ai(e,t,r,a){const s=Ft.setFromMatrixPosition(e.matrixWorld),o=s.clone();o.project(t),Or.set(o.x,o.y),r.setFromCamera(Or,t);const l=r.intersectObjects(a,!0);if(l.length){const u=l[0].distance;return s.distanceTo(r.ray.origin)<u}return!0}function Bi(e,t){if(t instanceof vr)return t.zoom;if(t instanceof gr){const r=Ft.setFromMatrixPosition(e.matrixWorld),a=xr.setFromMatrixPosition(t.matrixWorld),s=t.fov*Math.PI/180,o=r.distanceTo(a);return 1/(2*Math.tan(s/2)*o)}else return 1}function Di(e,t,r){if(t instanceof gr||t instanceof vr){const a=Ft.setFromMatrixPosition(e.matrixWorld),s=xr.setFromMatrixPosition(t.matrixWorld),o=a.distanceTo(s),l=(r[1]-r[0])/(t.far-t.near),u=r[1]-l*t.far;return Math.round(l*o+u)}}const dr=e=>Math.abs(e)<1e-10?0:e;function ln(e,t,r=""){let a="matrix3d(";for(let s=0;s!==16;s++)a+=dr(t[s]*e.elements[s])+(s!==15?",":")");return r+a}const Ni=(e=>t=>ln(t,e))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),Pi=(e=>(t,r)=>ln(t,e(r),"translate(-50%,-50%)"))(e=>[1/e,1/e,1/e,1,-1/e,-1/e,-1/e,-1,1/e,1/e,1/e,1,1,1,1,1]);function Oi(e){return e&&typeof e=="object"&&"current"in e}const Li=R.forwardRef(({children:e,eps:t=.001,style:r,className:a,prepend:s,center:o,fullscreen:l,portal:u,distanceFactor:d,sprite:m=!1,transform:v=!1,occlude:E,onOcclude:b,castShadow:B,receiveShadow:Z,material:Y,geometry:z,zIndexRange:G=[16777271,0],calculatePosition:P=Ci,as:D="div",wrapperClass:K,pointerEvents:V="auto",...L},ne)=>{const{gl:_,camera:S,scene:U,size:A,raycaster:k,events:$,viewport:O}=ze(),[W]=R.useState(()=>document.createElement(D)),F=R.useRef(),fe=R.useRef(null),Ve=R.useRef(0),Ee=R.useRef([0,0]),J=R.useRef(null),Ne=R.useRef(null),ee=(u==null?void 0:u.current)||$.connected||_.domElement.parentNode,le=R.useRef(null),we=R.useRef(!1),We=R.useMemo(()=>E&&E!=="blending"||Array.isArray(E)&&E.length&&Oi(E[0]),[E]);R.useLayoutEffect(()=>{const Te=_.domElement;E&&E==="blending"?(Te.style.zIndex=`${Math.floor(G[0]/2)}`,Te.style.position="absolute",Te.style.pointerEvents="none"):(Te.style.zIndex=null,Te.style.position=null,Te.style.pointerEvents=null)},[E]),R.useLayoutEffect(()=>{if(fe.current){const Te=F.current=Gn.createRoot(W);if(U.updateMatrixWorld(),v)W.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const ae=P(fe.current,S,A);W.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${ae[0]}px,${ae[1]}px,0);transform-origin:0 0;`}return ee&&(s?ee.prepend(W):ee.appendChild(W)),()=>{ee&&ee.removeChild(W),Te.unmount()}}},[ee,v]),R.useLayoutEffect(()=>{K&&(W.className=K)},[K]);const te=R.useMemo(()=>v?{position:"absolute",top:0,left:0,width:A.width,height:A.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:o?"translate3d(-50%,-50%,0)":"none",...l&&{top:-A.height/2,left:-A.width/2,width:A.width,height:A.height},...r},[r,o,l,A,v]),ke=R.useMemo(()=>({position:"absolute",pointerEvents:V}),[V]);R.useLayoutEffect(()=>{if(we.current=!1,v){var Te;(Te=F.current)==null||Te.render(R.createElement("div",{ref:J,style:te},R.createElement("div",{ref:Ne,style:ke},R.createElement("div",{ref:ne,className:a,style:r,children:e}))))}else{var ae;(ae=F.current)==null||ae.render(R.createElement("div",{ref:ne,style:te,className:a,children:e}))}});const Se=R.useRef(!0);mr(Te=>{if(fe.current){S.updateMatrixWorld(),fe.current.updateWorldMatrix(!0,!1);const ae=v?Ee.current:P(fe.current,S,A);if(v||Math.abs(Ve.current-S.zoom)>t||Math.abs(Ee.current[0]-ae[0])>t||Math.abs(Ee.current[1]-ae[1])>t){const Xe=Ii(fe.current,S);let Pe=!1;We&&(Array.isArray(E)?Pe=E.map(Ye=>Ye.current):E!=="blending"&&(Pe=[U]));const rt=Se.current;if(Pe){const Ye=Ai(fe.current,S,k,Pe);Se.current=Ye&&!Xe}else Se.current=!Xe;rt!==Se.current&&(b?b(!Se.current):W.style.display=Se.current?"block":"none");const ut=Math.floor(G[0]/2),rr=E?We?[G[0],ut]:[ut-1,0]:G;if(W.style.zIndex=`${Di(fe.current,S,rr)}`,v){const[Ye,kt]=[A.width/2,A.height/2],St=S.projectionMatrix.elements[5]*kt,{isOrthographicCamera:Ht,top:nr,left:ir,bottom:Gt,right:ar}=S,xt=Ni(S.matrixWorldInverse),sr=Ht?`scale(${St})translate(${dr(-(ar+ir)/2)}px,${dr((nr+Gt)/2)}px)`:`translateZ(${St}px)`;let Ke=fe.current.matrixWorld;m&&(Ke=S.matrixWorldInverse.clone().transpose().copyPosition(Ke).scale(fe.current.scale),Ke.elements[3]=Ke.elements[7]=Ke.elements[11]=0,Ke.elements[15]=1),W.style.width=A.width+"px",W.style.height=A.height+"px",W.style.perspective=Ht?"":`${St}px`,J.current&&Ne.current&&(J.current.style.transform=`${sr}${xt}translate(${Ye}px,${kt}px)`,Ne.current.style.transform=Pi(Ke,1/((d||10)/400)))}else{const Ye=d===void 0?1:Bi(fe.current,S)*d;W.style.transform=`translate3d(${ae[0]}px,${ae[1]}px,0) scale(${Ye})`}Ee.current=ae,Ve.current=S.zoom}}if(!We&&le.current&&!we.current)if(v){if(J.current){const ae=J.current.children[0];if(ae!=null&&ae.clientWidth&&ae!=null&&ae.clientHeight){const{isOrthographicCamera:Xe}=S;if(Xe||z)L.scale&&(Array.isArray(L.scale)?L.scale instanceof Qe?le.current.scale.copy(L.scale.clone().divideScalar(1)):le.current.scale.set(1/L.scale[0],1/L.scale[1],1/L.scale[2]):le.current.scale.setScalar(1/L.scale));else{const Pe=(d||10)/400,rt=ae.clientWidth*Pe,ut=ae.clientHeight*Pe;le.current.scale.set(rt,ut,1)}we.current=!0}}}else{const ae=W.children[0];if(ae!=null&&ae.clientWidth&&ae!=null&&ae.clientHeight){const Xe=1/O.factor,Pe=ae.clientWidth*Xe,rt=ae.clientHeight*Xe;le.current.scale.set(Pe,rt,1),we.current=!0}le.current.lookAt(Te.camera.position)}});const zt=R.useMemo(()=>({vertexShader:v?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[v]);return R.createElement("group",qr({},L,{ref:fe}),E&&!We&&R.createElement("mesh",{castShadow:B,receiveShadow:Z,ref:le},z||R.createElement("planeGeometry",null),Y||R.createElement("shaderMaterial",{side:ft,vertexShader:zt.vertexShader,fragmentShader:zt.fragmentShader})))}),Lr=e=>{let t;const r=new Set,a=(m,v)=>{const E=typeof m=="function"?m(t):m;if(!Object.is(E,t)){const b=t;t=v??(typeof E!="object"||E===null)?E:Object.assign({},t,E),r.forEach(B=>B(t,b))}},s=()=>t,u={setState:a,getState:s,getInitialState:()=>d,subscribe:m=>(r.add(m),()=>r.delete(m))},d=t=e(a,s,u);return u},Fi=e=>e?Lr(e):Lr,Ui=e=>e;function zi(e,t=Ui){const r=Dt.useSyncExternalStore(e.subscribe,()=>t(e.getState()),()=>t(e.getInitialState()));return Dt.useDebugValue(r),r}const Fr=e=>{const t=Fi(e),r=a=>zi(t,a);return Object.assign(r,t),r},ki=e=>e?Fr(e):Fr;let Rt=0;const Hi=ki(e=>(Zt.onStart=(t,r,a)=>{e({active:!0,item:t,loaded:r,total:a,progress:(r-Rt)/(a-Rt)*100})},Zt.onLoad=()=>{e({active:!1})},Zt.onError=t=>e(r=>({errors:[...r.errors,t]})),Zt.onProgress=(t,r,a)=>{r===a&&(Rt=a),e({active:!0,item:t,loaded:r,total:a,progress:(r-Rt)/(a-Rt)*100||100})},{errors:[],active:!1,progress:0,item:"",loaded:0,total:0}));let bt;function Gi(){var e;if(bt!==void 0)return bt;try{let t;const r=document.createElement("canvas");return bt=!!(window.WebGL2RenderingContext&&(t=r.getContext("webgl2"))),t&&((e=t.getExtension("WEBGL_lose_context"))==null||e.loseContext()),bt}catch{return bt=!1}}var Ue=Uint8Array,lt=Uint16Array,hr=Uint32Array,cn=new Ue([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),un=new Ue([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Vi=new Ue([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),dn=function(e,t){for(var r=new lt(31),a=0;a<31;++a)r[a]=t+=1<<e[a-1];for(var s=new hr(r[30]),a=1;a<30;++a)for(var o=r[a];o<r[a+1];++o)s[o]=o-r[a]<<5|a;return[r,s]},hn=dn(cn,2),fn=hn[0],Wi=hn[1];fn[28]=258,Wi[258]=28;var Zi=dn(un,0),$i=Zi[0],fr=new lt(32768);for(var he=0;he<32768;++he){var it=(he&43690)>>>1|(he&21845)<<1;it=(it&52428)>>>2|(it&13107)<<2,it=(it&61680)>>>4|(it&3855)<<4,fr[he]=((it&65280)>>>8|(it&255)<<8)>>>1}var Bt=function(e,t,r){for(var a=e.length,s=0,o=new lt(t);s<a;++s)++o[e[s]-1];var l=new lt(t);for(s=0;s<t;++s)l[s]=l[s-1]+o[s-1]<<1;var u;if(r){u=new lt(1<<t);var d=15-t;for(s=0;s<a;++s)if(e[s])for(var m=s<<4|e[s],v=t-e[s],E=l[e[s]-1]++<<v,b=E|(1<<v)-1;E<=b;++E)u[fr[E]>>>d]=m}else for(u=new lt(a),s=0;s<a;++s)e[s]&&(u[s]=fr[l[e[s]-1]++]>>>15-e[s]);return u},Ut=new Ue(288);for(var he=0;he<144;++he)Ut[he]=8;for(var he=144;he<256;++he)Ut[he]=9;for(var he=256;he<280;++he)Ut[he]=7;for(var he=280;he<288;++he)Ut[he]=8;var pn=new Ue(32);for(var he=0;he<32;++he)pn[he]=5;var ji=Bt(Ut,9,1),Xi=Bt(pn,5,1),or=function(e){for(var t=e[0],r=1;r<e.length;++r)e[r]>t&&(t=e[r]);return t},He=function(e,t,r){var a=t/8|0;return(e[a]|e[a+1]<<8)>>(t&7)&r},lr=function(e,t){var r=t/8|0;return(e[r]|e[r+1]<<8|e[r+2]<<16)>>(t&7)},Yi=function(e){return(e/8|0)+(e&7&&1)},Ki=function(e,t,r){(r==null||r>e.length)&&(r=e.length);var a=new(e instanceof lt?lt:e instanceof hr?hr:Ue)(r-t);return a.set(e.subarray(t,r)),a},qi=function(e,t,r){var a=e.length;if(!a||r&&!r.l&&a<5)return t||new Ue(0);var s=!t||r,o=!r||r.i;r||(r={}),t||(t=new Ue(a*3));var l=function(te){var ke=t.length;if(te>ke){var Se=new Ue(Math.max(ke*2,te));Se.set(t),t=Se}},u=r.f||0,d=r.p||0,m=r.b||0,v=r.l,E=r.d,b=r.m,B=r.n,Z=a*8;do{if(!v){r.f=u=He(e,d,1);var Y=He(e,d+1,3);if(d+=3,Y)if(Y==1)v=ji,E=Xi,b=9,B=5;else if(Y==2){var D=He(e,d,31)+257,K=He(e,d+10,15)+4,V=D+He(e,d+5,31)+1;d+=14;for(var L=new Ue(V),ne=new Ue(19),_=0;_<K;++_)ne[Vi[_]]=He(e,d+_*3,7);d+=K*3;for(var S=or(ne),U=(1<<S)-1,A=Bt(ne,S,1),_=0;_<V;){var k=A[He(e,d,U)];d+=k&15;var z=k>>>4;if(z<16)L[_++]=z;else{var $=0,O=0;for(z==16?(O=3+He(e,d,3),d+=2,$=L[_-1]):z==17?(O=3+He(e,d,7),d+=3):z==18&&(O=11+He(e,d,127),d+=7);O--;)L[_++]=$}}var W=L.subarray(0,D),F=L.subarray(D);b=or(W),B=or(F),v=Bt(W,b,1),E=Bt(F,B,1)}else throw"invalid block type";else{var z=Yi(d)+4,G=e[z-4]|e[z-3]<<8,P=z+G;if(P>a){if(o)throw"unexpected EOF";break}s&&l(m+G),t.set(e.subarray(z,P),m),r.b=m+=G,r.p=d=P*8;continue}if(d>Z){if(o)throw"unexpected EOF";break}}s&&l(m+131072);for(var fe=(1<<b)-1,Ve=(1<<B)-1,Ee=d;;Ee=d){var $=v[lr(e,d)&fe],J=$>>>4;if(d+=$&15,d>Z){if(o)throw"unexpected EOF";break}if(!$)throw"invalid length/literal";if(J<256)t[m++]=J;else if(J==256){Ee=d,v=null;break}else{var Ne=J-254;if(J>264){var _=J-257,ee=cn[_];Ne=He(e,d,(1<<ee)-1)+fn[_],d+=ee}var le=E[lr(e,d)&Ve],we=le>>>4;if(!le)throw"invalid distance";d+=le&15;var F=$i[we];if(we>3){var ee=un[we];F+=lr(e,d)&(1<<ee)-1,d+=ee}if(d>Z){if(o)throw"unexpected EOF";break}s&&l(m+131072);for(var We=m+Ne;m<We;m+=4)t[m]=t[m-F],t[m+1]=t[m+1-F],t[m+2]=t[m+2-F],t[m+3]=t[m+3-F];m=We}}r.l=v,r.p=Ee,r.b=m,v&&(u=1,r.m=b,r.d=E,r.n=B)}while(!u);return m==t.length?t:Ki(t,0,m)},Qi=new Ue(0),Ji=function(e){if((e[0]&15)!=8||e[0]>>>4>7||(e[0]<<8|e[1])%31)throw"invalid zlib data";if(e[1]&32)throw"invalid zlib data: preset dictionaries not supported"};function Xt(e,t){return qi((Ji(e),e.subarray(2,-4)),t)}var ea=typeof TextDecoder<"u"&&new TextDecoder,ta=0;try{ea.decode(Qi,{stream:!0}),ta=1}catch{}const ra=e=>e&&e.isCubeTexture;class na extends Lt{constructor(t,r){var a,s;const o=ra(t),u=((s=o?(a=t.image[0])==null?void 0:a.width:t.image.width)!=null?s:1024)/4,d=Math.floor(Math.log2(u)),m=Math.pow(2,d),v=3*Math.max(m,16*7),E=4*m,b=[o?"#define ENVMAP_TYPE_CUBE":"",`#define CUBEUV_TEXEL_WIDTH ${1/v}`,`#define CUBEUV_TEXEL_HEIGHT ${1/E}`,`#define CUBEUV_MAX_MIP ${d}.0`],B=`
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `,Z=b.join(`
`)+`
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${Qr>=154?"colorspace_fragment":"encodings_fragment"}>
        }
        `,Y={map:{value:t},height:{value:(r==null?void 0:r.height)||15},radius:{value:(r==null?void 0:r.radius)||100}},z=new jn(1,16),G=new tt({uniforms:Y,fragmentShader:Z,vertexShader:B,side:ft});super(z,G)}set radius(t){this.material.uniforms.radius.value=t}get radius(){return this.material.uniforms.radius.value}set height(t){this.material.uniforms.height.value=t}get height(){return this.material.uniforms.height.value}}class ia extends Jr{constructor(t){super(t),this.type=Be}parse(t){const l=function(_,S){switch(_){case 1:throw new Error("THREE.RGBELoader: Read Error: "+(S||""));case 2:throw new Error("THREE.RGBELoader: Write Error: "+(S||""));case 3:throw new Error("THREE.RGBELoader: Bad File Format: "+(S||""));default:case 4:throw new Error("THREE.RGBELoader: Memory Error: "+(S||""))}},v=`
`,E=function(_,S,U){S=S||1024;let k=_.pos,$=-1,O=0,W="",F=String.fromCharCode.apply(null,new Uint16Array(_.subarray(k,k+128)));for(;0>($=F.indexOf(v))&&O<S&&k<_.byteLength;)W+=F,O+=F.length,k+=128,F+=String.fromCharCode.apply(null,new Uint16Array(_.subarray(k,k+128)));return-1<$?(_.pos+=O+$+1,W+F.slice(0,$)):!1},b=function(_){const S=/^#\?(\S+)/,U=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,A=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,k=/^\s*FORMAT=(\S+)\s*$/,$=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,O={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let W,F;for((_.pos>=_.byteLength||!(W=E(_)))&&l(1,"no header found"),(F=W.match(S))||l(3,"bad initial token"),O.valid|=1,O.programtype=F[1],O.string+=W+`
`;W=E(_),W!==!1;){if(O.string+=W+`
`,W.charAt(0)==="#"){O.comments+=W+`
`;continue}if((F=W.match(U))&&(O.gamma=parseFloat(F[1])),(F=W.match(A))&&(O.exposure=parseFloat(F[1])),(F=W.match(k))&&(O.valid|=2,O.format=F[1]),(F=W.match($))&&(O.valid|=4,O.height=parseInt(F[1],10),O.width=parseInt(F[2],10)),O.valid&2&&O.valid&4)break}return O.valid&2||l(3,"missing format specifier"),O.valid&4||l(3,"missing image size specifier"),O},B=function(_,S,U){const A=S;if(A<8||A>32767||_[0]!==2||_[1]!==2||_[2]&128)return new Uint8Array(_);A!==(_[2]<<8|_[3])&&l(3,"wrong scanline width");const k=new Uint8Array(4*S*U);k.length||l(4,"unable to allocate buffer space");let $=0,O=0;const W=4*A,F=new Uint8Array(4),fe=new Uint8Array(W);let Ve=U;for(;Ve>0&&O<_.byteLength;){O+4>_.byteLength&&l(1),F[0]=_[O++],F[1]=_[O++],F[2]=_[O++],F[3]=_[O++],(F[0]!=2||F[1]!=2||(F[2]<<8|F[3])!=A)&&l(3,"bad rgbe scanline format");let Ee=0,J;for(;Ee<W&&O<_.byteLength;){J=_[O++];const ee=J>128;if(ee&&(J-=128),(J===0||Ee+J>W)&&l(3,"bad scanline data"),ee){const le=_[O++];for(let we=0;we<J;we++)fe[Ee++]=le}else fe.set(_.subarray(O,O+J),Ee),Ee+=J,O+=J}const Ne=A;for(let ee=0;ee<Ne;ee++){let le=0;k[$]=fe[ee+le],le+=A,k[$+1]=fe[ee+le],le+=A,k[$+2]=fe[ee+le],le+=A,k[$+3]=fe[ee+le],$+=4}Ve--}return k},Z=function(_,S,U,A){const k=_[S+3],$=Math.pow(2,k-128)/255;U[A+0]=_[S+0]*$,U[A+1]=_[S+1]*$,U[A+2]=_[S+2]*$,U[A+3]=1},Y=function(_,S,U,A){const k=_[S+3],$=Math.pow(2,k-128)/255;U[A+0]=pt.toHalfFloat(Math.min(_[S+0]*$,65504)),U[A+1]=pt.toHalfFloat(Math.min(_[S+1]*$,65504)),U[A+2]=pt.toHalfFloat(Math.min(_[S+2]*$,65504)),U[A+3]=pt.toHalfFloat(1)},z=new Uint8Array(t);z.pos=0;const G=b(z),P=G.width,D=G.height,K=B(z.subarray(z.pos),P,D);let V,L,ne;switch(this.type){case je:ne=K.length/4;const _=new Float32Array(ne*4);for(let U=0;U<ne;U++)Z(K,U*4,_,U*4);V=_,L=je;break;case Be:ne=K.length/4;const S=new Uint16Array(ne*4);for(let U=0;U<ne;U++)Y(K,U*4,S,U*4);V=S,L=Be;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+this.type)}return{width:P,height:D,data:V,header:G.string,gamma:G.gamma,exposure:G.exposure,type:L}}setDataType(t){return this.type=t,this}load(t,r,a,s){function o(l,u){switch(l.type){case je:case Be:"colorSpace"in l?l.colorSpace="srgb-linear":l.encoding=3e3,l.minFilter=Re,l.magFilter=Re,l.generateMipmaps=!1,l.flipY=!0;break}r&&r(l,u)}return super.load(t,o,a,s)}}const Ct=Qr>=152;class aa extends Jr{constructor(t){super(t),this.type=Be}parse(t){const S=Math.pow(2.7182818,2.2);function U(n,i){for(var c=0,h=0;h<65536;++h)(h==0||n[h>>3]&1<<(h&7))&&(i[c++]=h);for(var f=c-1;c<65536;)i[c++]=0;return f}function A(n){for(var i=0;i<16384;i++)n[i]={},n[i].len=0,n[i].lit=0,n[i].p=null}const k={l:0,c:0,lc:0};function $(n,i,c,h,f){for(;c<n;)i=i<<8|Ar(h,f),c+=8;c-=n,k.l=i>>c&(1<<n)-1,k.c=i,k.lc=c}const O=new Array(59);function W(n){for(var i=0;i<=58;++i)O[i]=0;for(var i=0;i<65537;++i)O[n[i]]+=1;for(var c=0,i=58;i>0;--i){var h=c+O[i]>>1;O[i]=c,c=h}for(var i=0;i<65537;++i){var f=n[i];f>0&&(n[i]=f|O[f]++<<6)}}function F(n,i,c,h,f,p,x){for(var g=c,M=0,T=0;f<=p;f++){if(g.value-c.value>h)return!1;$(6,M,T,n,g);var y=k.l;if(M=k.c,T=k.lc,x[f]=y,y==63){if(g.value-c.value>h)throw"Something wrong with hufUnpackEncTable";$(8,M,T,n,g);var w=k.l+6;if(M=k.c,T=k.lc,f+w>p+1)throw"Something wrong with hufUnpackEncTable";for(;w--;)x[f++]=0;f--}else if(y>=59){var w=y-59+2;if(f+w>p+1)throw"Something wrong with hufUnpackEncTable";for(;w--;)x[f++]=0;f--}}W(x)}function fe(n){return n&63}function Ve(n){return n>>6}function Ee(n,i,c,h){for(;i<=c;i++){var f=Ve(n[i]),p=fe(n[i]);if(f>>p)throw"Invalid table entry";if(p>14){var x=h[f>>p-14];if(x.len)throw"Invalid table entry";if(x.lit++,x.p){var g=x.p;x.p=new Array(x.lit);for(var M=0;M<x.lit-1;++M)x.p[M]=g[M]}else x.p=new Array(1);x.p[x.lit-1]=i}else if(p)for(var T=0,M=1<<14-p;M>0;M--){var x=h[(f<<14-p)+T];if(x.len||x.p)throw"Invalid table entry";x.len=p,x.lit=i,T++}}return!0}const J={c:0,lc:0};function Ne(n,i,c,h){n=n<<8|Ar(c,h),i+=8,J.c=n,J.lc=i}const ee={c:0,lc:0};function le(n,i,c,h,f,p,x,g,M,T){if(n==i){h<8&&(Ne(c,h,f,x),c=J.c,h=J.lc),h-=8;var y=c>>h,y=new Uint8Array([y])[0];if(M.value+y>T)return!1;for(var w=g[M.value-1];y-- >0;)g[M.value++]=w}else if(M.value<T)g[M.value++]=n;else return!1;ee.c=c,ee.lc=h}function we(n){return n&65535}function We(n){var i=we(n);return i>32767?i-65536:i}const te={a:0,b:0};function ke(n,i){var c=We(n),h=We(i),f=h,p=c+(f&1)+(f>>1),x=p,g=p-f;te.a=x,te.b=g}function Se(n,i){var c=we(n),h=we(i),f=c-(h>>1)&65535,p=h+f-32768&65535;te.a=p,te.b=f}function zt(n,i,c,h,f,p,x){for(var g=x<16384,M=c>f?f:c,T=1,y;T<=M;)T<<=1;for(T>>=1,y=T,T>>=1;T>=1;){for(var w=0,me=w+p*(f-y),I=p*T,N=p*y,H=h*T,j=h*y,se,ce,ve,Me;w<=me;w+=N){for(var ue=w,Ze=w+h*(c-y);ue<=Ze;ue+=j){var de=ue+H,ge=ue+I,qe=ge+H;g?(ke(n[ue+i],n[ge+i]),se=te.a,ve=te.b,ke(n[de+i],n[qe+i]),ce=te.a,Me=te.b,ke(se,ce),n[ue+i]=te.a,n[de+i]=te.b,ke(ve,Me),n[ge+i]=te.a,n[qe+i]=te.b):(Se(n[ue+i],n[ge+i]),se=te.a,ve=te.b,Se(n[de+i],n[qe+i]),ce=te.a,Me=te.b,Se(se,ce),n[ue+i]=te.a,n[de+i]=te.b,Se(ve,Me),n[ge+i]=te.a,n[qe+i]=te.b)}if(c&T){var ge=ue+I;g?ke(n[ue+i],n[ge+i]):Se(n[ue+i],n[ge+i]),se=te.a,n[ge+i]=te.b,n[ue+i]=se}}if(f&T)for(var ue=w,Ze=w+h*(c-y);ue<=Ze;ue+=j){var de=ue+H;g?ke(n[ue+i],n[de+i]):Se(n[ue+i],n[de+i]),se=te.a,n[de+i]=te.b,n[ue+i]=se}y=T,T>>=1}return w}function Te(n,i,c,h,f,p,x,g,M,T){for(var y=0,w=0,me=g,I=Math.trunc(f.value+(p+7)/8);f.value<I;)for(Ne(y,w,c,f),y=J.c,w=J.lc;w>=14;){var N=y>>w-14&16383,H=i[N];if(H.len)w-=H.len,le(H.lit,x,y,w,c,h,f,M,T,me),y=ee.c,w=ee.lc;else{if(!H.p)throw"hufDecode issues";var j;for(j=0;j<H.lit;j++){for(var se=fe(n[H.p[j]]);w<se&&f.value<I;)Ne(y,w,c,f),y=J.c,w=J.lc;if(w>=se&&Ve(n[H.p[j]])==(y>>w-se&(1<<se)-1)){w-=se,le(H.p[j],x,y,w,c,h,f,M,T,me),y=ee.c,w=ee.lc;break}}if(j==H.lit)throw"hufDecode issues"}}var ce=8-p&7;for(y>>=ce,w-=ce;w>0;){var H=i[y<<14-w&16383];if(H.len)w-=H.len,le(H.lit,x,y,w,c,h,f,M,T,me),y=ee.c,w=ee.lc;else throw"hufDecode issues"}return!0}function ae(n,i,c,h,f,p){var x={value:0},g=c.value,M=ye(i,c),T=ye(i,c);c.value+=4;var y=ye(i,c);if(c.value+=4,M<0||M>=65537||T<0||T>=65537)throw"Something wrong with HUF_ENCSIZE";var w=new Array(65537),me=new Array(16384);A(me);var I=h-(c.value-g);if(F(n,i,c,I,M,T,w),y>8*(h-(c.value-g)))throw"Something wrong with hufUncompress";Ee(w,M,T,me),Te(w,me,n,i,c,y,T,p,f,x)}function Xe(n,i,c){for(var h=0;h<c;++h)i[h]=n[i[h]]}function Pe(n){for(var i=1;i<n.length;i++){var c=n[i-1]+n[i]-128;n[i]=c}}function rt(n,i){for(var c=0,h=Math.floor((n.length+1)/2),f=0,p=n.length-1;!(f>p||(i[f++]=n[c++],f>p));)i[f++]=n[h++]}function ut(n){for(var i=n.byteLength,c=new Array,h=0,f=new DataView(n);i>0;){var p=f.getInt8(h++);if(p<0){var x=-p;i-=x+1;for(var g=0;g<x;g++)c.push(f.getUint8(h++))}else{var x=p;i-=2;for(var M=f.getUint8(h++),g=0;g<x+1;g++)c.push(M)}}return c}function rr(n,i,c,h,f,p){var de=new DataView(p.buffer),x=c[n.idx[0]].width,g=c[n.idx[0]].height,M=3,T=Math.floor(x/8),y=Math.ceil(x/8),w=Math.ceil(g/8),me=x-(y-1)*8,I=g-(w-1)*8,N={value:0},H=new Array(M),j=new Array(M),se=new Array(M),ce=new Array(M),ve=new Array(M);for(let oe=0;oe<M;++oe)ve[oe]=i[n.idx[oe]],H[oe]=oe<1?0:H[oe-1]+y*w,j[oe]=new Float32Array(64),se[oe]=new Uint16Array(64),ce[oe]=new Uint16Array(y*64);for(let oe=0;oe<w;++oe){var Me=8;oe==w-1&&(Me=I);var ue=8;for(let pe=0;pe<y;++pe){pe==y-1&&(ue=me);for(let ie=0;ie<M;++ie)se[ie].fill(0),se[ie][0]=f[H[ie]++],Ye(N,h,se[ie]),kt(se[ie],j[ie]),St(j[ie]);Ht(j);for(let ie=0;ie<M;++ie)nr(j[ie],ce[ie],pe*64)}let _e=0;for(let pe=0;pe<M;++pe){const ie=c[n.idx[pe]].type;for(let Fe=8*oe;Fe<8*oe+Me;++Fe){_e=ve[pe][Fe];for(let dt=0;dt<T;++dt){const be=dt*64+(Fe&7)*8;de.setUint16(_e+0*2*ie,ce[pe][be+0],!0),de.setUint16(_e+1*2*ie,ce[pe][be+1],!0),de.setUint16(_e+2*2*ie,ce[pe][be+2],!0),de.setUint16(_e+3*2*ie,ce[pe][be+3],!0),de.setUint16(_e+4*2*ie,ce[pe][be+4],!0),de.setUint16(_e+5*2*ie,ce[pe][be+5],!0),de.setUint16(_e+6*2*ie,ce[pe][be+6],!0),de.setUint16(_e+7*2*ie,ce[pe][be+7],!0),_e+=8*2*ie}}if(T!=y)for(let Fe=8*oe;Fe<8*oe+Me;++Fe){const dt=ve[pe][Fe]+8*T*2*ie,be=T*64+(Fe&7)*8;for(let nt=0;nt<ue;++nt)de.setUint16(dt+nt*2*ie,ce[pe][be+nt],!0)}}}for(var Ze=new Uint16Array(x),de=new DataView(p.buffer),ge=0;ge<M;++ge){c[n.idx[ge]].decoded=!0;var qe=c[n.idx[ge]].type;if(c[ge].type==2)for(var yt=0;yt<g;++yt){const oe=ve[ge][yt];for(var Le=0;Le<x;++Le)Ze[Le]=de.getUint16(oe+Le*2*qe,!0);for(var Le=0;Le<x;++Le)de.setFloat32(oe+Le*2*qe,C(Ze[Le]),!0)}}}function Ye(n,i,c){for(var h,f=1;f<64;)h=i[n.value],h==65280?f=64:h>>8==255?f+=h&255:(c[f]=h,f++),n.value++}function kt(n,i){i[0]=C(n[0]),i[1]=C(n[1]),i[2]=C(n[5]),i[3]=C(n[6]),i[4]=C(n[14]),i[5]=C(n[15]),i[6]=C(n[27]),i[7]=C(n[28]),i[8]=C(n[2]),i[9]=C(n[4]),i[10]=C(n[7]),i[11]=C(n[13]),i[12]=C(n[16]),i[13]=C(n[26]),i[14]=C(n[29]),i[15]=C(n[42]),i[16]=C(n[3]),i[17]=C(n[8]),i[18]=C(n[12]),i[19]=C(n[17]),i[20]=C(n[25]),i[21]=C(n[30]),i[22]=C(n[41]),i[23]=C(n[43]),i[24]=C(n[9]),i[25]=C(n[11]),i[26]=C(n[18]),i[27]=C(n[24]),i[28]=C(n[31]),i[29]=C(n[40]),i[30]=C(n[44]),i[31]=C(n[53]),i[32]=C(n[10]),i[33]=C(n[19]),i[34]=C(n[23]),i[35]=C(n[32]),i[36]=C(n[39]),i[37]=C(n[45]),i[38]=C(n[52]),i[39]=C(n[54]),i[40]=C(n[20]),i[41]=C(n[22]),i[42]=C(n[33]),i[43]=C(n[38]),i[44]=C(n[46]),i[45]=C(n[51]),i[46]=C(n[55]),i[47]=C(n[60]),i[48]=C(n[21]),i[49]=C(n[34]),i[50]=C(n[37]),i[51]=C(n[47]),i[52]=C(n[50]),i[53]=C(n[56]),i[54]=C(n[59]),i[55]=C(n[61]),i[56]=C(n[35]),i[57]=C(n[36]),i[58]=C(n[48]),i[59]=C(n[49]),i[60]=C(n[57]),i[61]=C(n[58]),i[62]=C(n[62]),i[63]=C(n[63])}function St(n){const i=.5*Math.cos(.7853975),c=.5*Math.cos(3.14159/16),h=.5*Math.cos(3.14159/8),f=.5*Math.cos(3*3.14159/16),p=.5*Math.cos(5*3.14159/16),x=.5*Math.cos(3*3.14159/8),g=.5*Math.cos(7*3.14159/16);for(var M=new Array(4),T=new Array(4),y=new Array(4),w=new Array(4),me=0;me<8;++me){var I=me*8;M[0]=h*n[I+2],M[1]=x*n[I+2],M[2]=h*n[I+6],M[3]=x*n[I+6],T[0]=c*n[I+1]+f*n[I+3]+p*n[I+5]+g*n[I+7],T[1]=f*n[I+1]-g*n[I+3]-c*n[I+5]-p*n[I+7],T[2]=p*n[I+1]-c*n[I+3]+g*n[I+5]+f*n[I+7],T[3]=g*n[I+1]-p*n[I+3]+f*n[I+5]-c*n[I+7],y[0]=i*(n[I+0]+n[I+4]),y[3]=i*(n[I+0]-n[I+4]),y[1]=M[0]+M[3],y[2]=M[1]-M[2],w[0]=y[0]+y[1],w[1]=y[3]+y[2],w[2]=y[3]-y[2],w[3]=y[0]-y[1],n[I+0]=w[0]+T[0],n[I+1]=w[1]+T[1],n[I+2]=w[2]+T[2],n[I+3]=w[3]+T[3],n[I+4]=w[3]-T[3],n[I+5]=w[2]-T[2],n[I+6]=w[1]-T[1],n[I+7]=w[0]-T[0]}for(var N=0;N<8;++N)M[0]=h*n[16+N],M[1]=x*n[16+N],M[2]=h*n[48+N],M[3]=x*n[48+N],T[0]=c*n[8+N]+f*n[24+N]+p*n[40+N]+g*n[56+N],T[1]=f*n[8+N]-g*n[24+N]-c*n[40+N]-p*n[56+N],T[2]=p*n[8+N]-c*n[24+N]+g*n[40+N]+f*n[56+N],T[3]=g*n[8+N]-p*n[24+N]+f*n[40+N]-c*n[56+N],y[0]=i*(n[N]+n[32+N]),y[3]=i*(n[N]-n[32+N]),y[1]=M[0]+M[3],y[2]=M[1]-M[2],w[0]=y[0]+y[1],w[1]=y[3]+y[2],w[2]=y[3]-y[2],w[3]=y[0]-y[1],n[0+N]=w[0]+T[0],n[8+N]=w[1]+T[1],n[16+N]=w[2]+T[2],n[24+N]=w[3]+T[3],n[32+N]=w[3]-T[3],n[40+N]=w[2]-T[2],n[48+N]=w[1]-T[1],n[56+N]=w[0]-T[0]}function Ht(n){for(var i=0;i<64;++i){var c=n[0][i],h=n[1][i],f=n[2][i];n[0][i]=c+1.5747*f,n[1][i]=c-.1873*h-.4682*f,n[2][i]=c+1.8556*h}}function nr(n,i,c){for(var h=0;h<64;++h)i[c+h]=pt.toHalfFloat(ir(n[h]))}function ir(n){return n<=1?Math.sign(n)*Math.pow(Math.abs(n),2.2):Math.sign(n)*Math.pow(S,Math.abs(n)-1)}function Gt(n){return new DataView(n.array.buffer,n.offset.value,n.size)}function ar(n){var i=n.viewer.buffer.slice(n.offset.value,n.offset.value+n.size),c=new Uint8Array(ut(i)),h=new Uint8Array(c.length);return Pe(c),rt(c,h),new DataView(h.buffer)}function xt(n){var i=n.array.slice(n.offset.value,n.offset.value+n.size),c=Xt(i),h=new Uint8Array(c.length);return Pe(c),rt(c,h),new DataView(h.buffer)}function sr(n){for(var i=n.viewer,c={value:n.offset.value},h=new Uint16Array(n.width*n.scanlineBlockSize*(n.channels*n.type)),f=new Uint8Array(8192),p=0,x=new Array(n.channels),g=0;g<n.channels;g++)x[g]={},x[g].start=p,x[g].end=x[g].start,x[g].nx=n.width,x[g].ny=n.lines,x[g].size=n.type,p+=x[g].nx*x[g].ny*x[g].size;var M=wt(i,c),T=wt(i,c);if(T>=8192)throw"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";if(M<=T)for(var g=0;g<T-M+1;g++)f[g+M]=ht(i,c);var y=new Uint16Array(65536),w=U(f,y),me=ye(i,c);ae(n.array,i,c,me,h,p);for(var g=0;g<n.channels;++g)for(var I=x[g],N=0;N<x[g].size;++N)zt(h,I.start+N,I.nx,I.size,I.ny,I.nx*I.size,w);Xe(y,h,p);for(var H=0,j=new Uint8Array(h.buffer.byteLength),se=0;se<n.lines;se++)for(var ce=0;ce<n.channels;ce++){var I=x[ce],ve=I.nx*I.size,Me=new Uint8Array(h.buffer,I.end*2,ve*2);j.set(Me,H),H+=ve*2,I.end+=ve}return new DataView(j.buffer)}function Ke(n){var i=n.array.slice(n.offset.value,n.offset.value+n.size),c=Xt(i);const h=n.lines*n.channels*n.width,f=n.type==1?new Uint16Array(h):new Uint32Array(h);let p=0,x=0;const g=new Array(4);for(let M=0;M<n.lines;M++)for(let T=0;T<n.channels;T++){let y=0;switch(n.type){case 1:g[0]=p,g[1]=g[0]+n.width,p=g[1]+n.width;for(let w=0;w<n.width;++w){const me=c[g[0]++]<<8|c[g[1]++];y+=me,f[x]=y,x++}break;case 2:g[0]=p,g[1]=g[0]+n.width,g[2]=g[1]+n.width,p=g[2]+n.width;for(let w=0;w<n.width;++w){const me=c[g[0]++]<<24|c[g[1]++]<<16|c[g[2]++]<<8;y+=me,f[x]=y,x++}break}}return new DataView(f.buffer)}function Ir(n){var i=n.viewer,c={value:n.offset.value},h=new Uint8Array(n.width*n.lines*(n.channels*n.type*2)),f={version:Oe(i,c),unknownUncompressedSize:Oe(i,c),unknownCompressedSize:Oe(i,c),acCompressedSize:Oe(i,c),dcCompressedSize:Oe(i,c),rleCompressedSize:Oe(i,c),rleUncompressedSize:Oe(i,c),rleRawSize:Oe(i,c),totalAcUncompressedCount:Oe(i,c),totalDcUncompressedCount:Oe(i,c),acCompression:Oe(i,c)};if(f.version<2)throw"EXRLoader.parse: "+Mt.compression+" version "+f.version+" is unsupported";for(var p=new Array,x=wt(i,c)-2;x>0;){var g=Vt(i.buffer,c),M=ht(i,c),T=M>>2&3,y=(M>>4)-1,w=new Int8Array([y])[0],me=ht(i,c);p.push({name:g,index:w,type:me,compression:T}),x-=g.length+3}for(var I=Mt.channels,N=new Array(n.channels),H=0;H<n.channels;++H){var j=N[H]={},se=I[H];j.name=se.name,j.compression=0,j.decoded=!1,j.type=se.pixelType,j.pLinear=se.pLinear,j.width=n.width,j.height=n.lines}for(var ce={idx:new Array(3)},ve=0;ve<n.channels;++ve)for(var j=N[ve],H=0;H<p.length;++H){var Me=p[H];j.name==Me.name&&(j.compression=Me.compression,Me.index>=0&&(ce.idx[Me.index]=ve),j.offset=ve)}if(f.acCompressedSize>0)switch(f.acCompression){case 0:var de=new Uint16Array(f.totalAcUncompressedCount);ae(n.array,i,c,f.acCompressedSize,de,f.totalAcUncompressedCount);break;case 1:var ue=n.array.slice(c.value,c.value+f.totalAcUncompressedCount),Ze=Xt(ue),de=new Uint16Array(Ze.buffer);c.value+=f.totalAcUncompressedCount;break}if(f.dcCompressedSize>0){var ge={array:n.array,offset:c,size:f.dcCompressedSize},qe=new Uint16Array(xt(ge).buffer);c.value+=f.dcCompressedSize}if(f.rleRawSize>0){var ue=n.array.slice(c.value,c.value+f.rleCompressedSize),Ze=Xt(ue),yt=ut(Ze.buffer);c.value+=f.rleCompressedSize}for(var Le=0,oe=new Array(N.length),H=0;H<oe.length;++H)oe[H]=new Array;for(var _e=0;_e<n.lines;++_e)for(var pe=0;pe<N.length;++pe)oe[pe].push(Le),Le+=N[pe].width*n.type*2;rr(ce,oe,N,de,qe,h);for(var H=0;H<N.length;++H){var j=N[H];if(!j.decoded)switch(j.compression){case 2:for(var ie=0,Fe=0,_e=0;_e<n.lines;++_e){for(var dt=oe[H][ie],be=0;be<j.width;++be){for(var nt=0;nt<2*j.type;++nt)h[dt++]=yt[Fe+nt*j.width*j.height];Fe++}ie++}break;case 1:default:throw"EXRLoader.parse: unsupported channel compression"}}return new DataView(h.buffer)}function Vt(n,i){for(var c=new Uint8Array(n),h=0;c[i.value+h]!=0;)h+=1;var f=new TextDecoder().decode(c.slice(i.value,i.value+h));return i.value=i.value+h+1,f}function yn(n,i,c){var h=new TextDecoder().decode(new Uint8Array(n).slice(i.value,i.value+c));return i.value=i.value+c,h}function Rn(n,i){var c=_t(n,i),h=ye(n,i);return[c,h]}function bn(n,i){var c=ye(n,i),h=ye(n,i);return[c,h]}function _t(n,i){var c=n.getInt32(i.value,!0);return i.value=i.value+4,c}function ye(n,i){var c=n.getUint32(i.value,!0);return i.value=i.value+4,c}function Ar(n,i){var c=n[i.value];return i.value=i.value+1,c}function ht(n,i){var c=n.getUint8(i.value);return i.value=i.value+1,c}const Oe=function(n,i){let c;return"getBigInt64"in DataView.prototype?c=Number(n.getBigInt64(i.value,!0)):c=n.getUint32(i.value+4,!0)+Number(n.getUint32(i.value,!0)<<32),i.value+=8,c};function xe(n,i){var c=n.getFloat32(i.value,!0);return i.value+=4,c}function Cn(n,i){return pt.toHalfFloat(xe(n,i))}function C(n){var i=(n&31744)>>10,c=n&1023;return(n>>15?-1:1)*(i?i===31?c?NaN:1/0:Math.pow(2,i-15)*(1+c/1024):6103515625e-14*(c/1024))}function wt(n,i){var c=n.getUint16(i.value,!0);return i.value+=2,c}function In(n,i){return C(wt(n,i))}function An(n,i,c,h){for(var f=c.value,p=[];c.value<f+h-1;){var x=Vt(i,c),g=_t(n,c),M=ht(n,c);c.value+=3;var T=_t(n,c),y=_t(n,c);p.push({name:x,pixelType:g,pLinear:M,xSampling:T,ySampling:y})}return c.value+=1,p}function Bn(n,i){var c=xe(n,i),h=xe(n,i),f=xe(n,i),p=xe(n,i),x=xe(n,i),g=xe(n,i),M=xe(n,i),T=xe(n,i);return{redX:c,redY:h,greenX:f,greenY:p,blueX:x,blueY:g,whiteX:M,whiteY:T}}function Dn(n,i){var c=["NO_COMPRESSION","RLE_COMPRESSION","ZIPS_COMPRESSION","ZIP_COMPRESSION","PIZ_COMPRESSION","PXR24_COMPRESSION","B44_COMPRESSION","B44A_COMPRESSION","DWAA_COMPRESSION","DWAB_COMPRESSION"],h=ht(n,i);return c[h]}function Nn(n,i){var c=ye(n,i),h=ye(n,i),f=ye(n,i),p=ye(n,i);return{xMin:c,yMin:h,xMax:f,yMax:p}}function Pn(n,i){var c=["INCREASING_Y"],h=ht(n,i);return c[h]}function On(n,i){var c=xe(n,i),h=xe(n,i);return[c,h]}function Ln(n,i){var c=xe(n,i),h=xe(n,i),f=xe(n,i);return[c,h,f]}function Fn(n,i,c,h,f){if(h==="string"||h==="stringvector"||h==="iccProfile")return yn(i,c,f);if(h==="chlist")return An(n,i,c,f);if(h==="chromaticities")return Bn(n,c);if(h==="compression")return Dn(n,c);if(h==="box2i")return Nn(n,c);if(h==="lineOrder")return Pn(n,c);if(h==="float")return xe(n,c);if(h==="v2f")return On(n,c);if(h==="v3f")return Ln(n,c);if(h==="int")return _t(n,c);if(h==="rational")return Rn(n,c);if(h==="timecode")return bn(n,c);if(h==="preview")return c.value+=f,"skipped";c.value+=f}function Un(n,i,c){const h={};if(n.getUint32(0,!0)!=20000630)throw"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";h.version=n.getUint8(4);const f=n.getUint8(5);h.spec={singleTile:!!(f&2),longName:!!(f&4),deepFormat:!!(f&8),multiPart:!!(f&16)},c.value=8;for(var p=!0;p;){var x=Vt(i,c);if(x==0)p=!1;else{var g=Vt(i,c),M=ye(n,c),T=Fn(n,i,c,g,M);T===void 0?console.warn(`EXRLoader.parse: skipped unknown header attribute type '${g}'.`):h[x]=T}}if(f&-5)throw console.error("EXRHeader:",h),"THREE.EXRLoader: provided file is currently unsupported.";return h}function zn(n,i,c,h,f){const p={size:0,viewer:i,array:c,offset:h,width:n.dataWindow.xMax-n.dataWindow.xMin+1,height:n.dataWindow.yMax-n.dataWindow.yMin+1,channels:n.channels.length,bytesPerLine:null,lines:null,inputSize:null,type:n.channels[0].pixelType,uncompress:null,getter:null,format:null,[Ct?"colorSpace":"encoding"]:null};switch(n.compression){case"NO_COMPRESSION":p.lines=1,p.uncompress=Gt;break;case"RLE_COMPRESSION":p.lines=1,p.uncompress=ar;break;case"ZIPS_COMPRESSION":p.lines=1,p.uncompress=xt;break;case"ZIP_COMPRESSION":p.lines=16,p.uncompress=xt;break;case"PIZ_COMPRESSION":p.lines=32,p.uncompress=sr;break;case"PXR24_COMPRESSION":p.lines=16,p.uncompress=Ke;break;case"DWAA_COMPRESSION":p.lines=32,p.uncompress=Ir;break;case"DWAB_COMPRESSION":p.lines=256,p.uncompress=Ir;break;default:throw"EXRLoader.parse: "+n.compression+" is unsupported"}if(p.scanlineBlockSize=p.lines,p.type==1)switch(f){case je:p.getter=In,p.inputSize=2;break;case Be:p.getter=wt,p.inputSize=2;break}else if(p.type==2)switch(f){case je:p.getter=xe,p.inputSize=4;break;case Be:p.getter=Cn,p.inputSize=4}else throw"EXRLoader.parse: unsupported pixelType "+p.type+" for "+n.compression+".";p.blockCount=(n.dataWindow.yMax+1)/p.scanlineBlockSize;for(var x=0;x<p.blockCount;x++)Oe(i,h);p.outputChannels=p.channels==3?4:p.channels;const g=p.width*p.height*p.outputChannels;switch(f){case je:p.byteArray=new Float32Array(g),p.channels<p.outputChannels&&p.byteArray.fill(1,0,g);break;case Be:p.byteArray=new Uint16Array(g),p.channels<p.outputChannels&&p.byteArray.fill(15360,0,g);break;default:console.error("THREE.EXRLoader: unsupported type: ",f);break}return p.bytesPerLine=p.width*p.inputSize*p.channels,p.outputChannels==4?p.format=Nt:p.format=Xn,Ct?p.colorSpace="srgb-linear":p.encoding=3e3,p}const Wt=new DataView(t),kn=new Uint8Array(t),Tt={value:0},Mt=Un(Wt,t,Tt),q=zn(Mt,Wt,kn,Tt,this.type),Br={value:0},Hn={R:0,G:1,B:2,A:3,Y:0};for(let n=0;n<q.height/q.scanlineBlockSize;n++){const i=ye(Wt,Tt);q.size=ye(Wt,Tt),q.lines=i+q.scanlineBlockSize>q.height?q.height-i:q.scanlineBlockSize;const h=q.size<q.lines*q.bytesPerLine?q.uncompress(q):Gt(q);Tt.value+=q.size;for(let f=0;f<q.scanlineBlockSize;f++){const p=f+n*q.scanlineBlockSize;if(p>=q.height)break;for(let x=0;x<q.channels;x++){const g=Hn[Mt.channels[x].name];for(let M=0;M<q.width;M++){Br.value=(f*(q.channels*q.width)+x*q.width+M)*q.inputSize;const T=(q.height-1-p)*(q.width*q.outputChannels)+M*q.outputChannels+g;q.byteArray[T]=q.getter(h,Br)}}}}return{header:Mt,width:q.width,height:q.height,data:q.byteArray,format:q.format,[Ct?"colorSpace":"encoding"]:q[Ct?"colorSpace":"encoding"],type:this.type}}setDataType(t){return this.type=t,this}load(t,r,a,s){function o(l,u){Ct?l.colorSpace=u.colorSpace:l.encoding=u.encoding,l.minFilter=Re,l.magFilter=Re,l.generateMipmaps=!1,l.flipY=!1,r&&r(l,u)}return super.load(t,o,a,s)}}const sa=3e3,oa=3001,la=({focus:e=0,size:t=25,samples:r=10}={})=>`
#define PENUMBRA_FILTER_SIZE float(${t})
#define RGB_NOISE_FUNCTION(uv) (randRGB(uv))
vec3 randRGB(vec2 uv) {
  return vec3(
    fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575),
    fract(sin(dot(uv, vec2(19.45531, 58.46547))) * 43678.23431),
    fract(sin(dot(uv, vec2(23.67817, 78.23121))) * 93567.23423)
  );
}

vec3 lowPassRandRGB(vec2 uv) {
  // 3x3 convolution (average)
  // can be implemented as separable with an extra buffer for a total of 6 samples instead of 9
  vec3 result = vec3(0);
  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, -1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0,  0.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, +1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, -1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0,  0.0));
  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, +1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, -1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0,  0.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, +1.0));
  result *= 0.111111111; // 1.0 / 9.0
  return result;
}
vec3 highPassRandRGB(vec2 uv) {
  // by subtracting the low-pass signal from the original signal, we're being left with the high-pass signal
  // hp(x) = x - lp(x)
  return RGB_NOISE_FUNCTION(uv) - lowPassRandRGB(uv) + 0.5;
}


vec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {
  const float goldenAngle = 2.399963f; // radians
  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));
  float theta = float(sampleIndex) * goldenAngle + angle;
  float sine = sin(theta);
  float cosine = cos(theta);
  return vec2(cosine, sine) * r;
}
float penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation
  return (zReceiver - zBlocker) / zBlocker;
}
float findBlocker(sampler2D shadowMap, vec2 uv, float compare, float angle) {
  float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
  float blockerDepthSum = float(${e});
  float blockers = 0.0;

  int j = 0;
  vec2 offset = vec2(0.);
  float depth = 0.;

  #pragma unroll_loop_start
  for(int i = 0; i < ${r}; i ++) {
    offset = (vogelDiskSample(j, ${r}, angle) * texelSize) * 2.0 * PENUMBRA_FILTER_SIZE;
    depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset));
    if (depth < compare) {
      blockerDepthSum += depth;
      blockers++;
    }
    j++;
  }
  #pragma unroll_loop_end

  if (blockers > 0.0) {
    return blockerDepthSum / blockers;
  }
  return -1.0;
}

        
float vogelFilter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius, float angle) {
  float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
  float shadow = 0.0f;
  int j = 0;
  vec2 vogelSample = vec2(0.0);
  vec2 offset = vec2(0.0);
  #pragma unroll_loop_start
  for (int i = 0; i < ${r}; i++) {
    vogelSample = vogelDiskSample(j, ${r}, angle) * texelSize;
    offset = vogelSample * (1.0 + filterRadius * float(${t}));
    shadow += step( zReceiver, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );
    j++;
  }
  #pragma unroll_loop_end
  return shadow * 1.0 / ${r}.0;
}

float PCSS (sampler2D shadowMap, vec4 coords) {
  vec2 uv = coords.xy;
  float zReceiver = coords.z; // Assumed to be eye-space z in this code
  float angle = highPassRandRGB(gl_FragCoord.xy).r * PI2;
  float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver, angle);
  if (avgBlockerDepth == -1.0) {
    return 1.0;
  }
  float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);
  return vogelFilter(shadowMap, uv, zReceiver, 1.25 * penumbraRatio, angle);
}`;function Ur(e,t,r){t.traverse(a=>{a.material&&(e.properties.remove(a.material),a.material.dispose==null||a.material.dispose())}),e.info.programs.length=0,e.compile(t,r)}function ks({focus:e=0,samples:t=10,size:r=25}){const a=ze(l=>l.gl),s=ze(l=>l.scene),o=ze(l=>l.camera);return R.useEffect(()=>{const l=$t.shadowmap_pars_fragment;return $t.shadowmap_pars_fragment=$t.shadowmap_pars_fragment.replace("#ifdef USE_SHADOWMAP",`#ifdef USE_SHADOWMAP
`+la({size:r,samples:t,focus:e})).replace("#if defined( SHADOWMAP_TYPE_PCF )",`
return PCSS(shadowMap, shadowCoord);
#if defined( SHADOWMAP_TYPE_PCF )`),Ur(a,s,o),()=>{$t.shadowmap_pars_fragment=l,Ur(a,s,o)}},[e,r,t]),null}const mn=(e,t,r)=>{let a;switch(e){case ct:a=new Uint8ClampedArray(t*r*4);break;case Be:a=new Uint16Array(t*r*4);break;case tn:a=new Uint32Array(t*r*4);break;case Jn:a=new Int8Array(t*r*4);break;case Qn:a=new Int16Array(t*r*4);break;case qn:a=new Int32Array(t*r*4);break;case je:a=new Float32Array(t*r*4);break;default:throw new Error("Unsupported data type")}return a};let Yt;const ca=(e,t,r,a)=>{if(Yt!==void 0)return Yt;const s=new Ge(1,1,a);t.setRenderTarget(s);const o=new Lt(new en,new rn({color:16777215}));t.render(o,r),t.setRenderTarget(null);const l=mn(e,s.width,s.height);return t.readRenderTargetPixels(s,0,0,s.width,s.height,l),s.dispose(),o.geometry.dispose(),o.material.dispose(),Yt=l[0]!==0,Yt};class _r{constructor(t){var r,a,s,o,l,u,d,m,v,E,b,B,Z,Y,z,G;this._rendererIsDisposable=!1,this._supportsReadPixels=!0,this.render=()=>{this._renderer.setRenderTarget(this._renderTarget);try{this._renderer.render(this._scene,this._camera)}catch(D){throw this._renderer.setRenderTarget(null),D}this._renderer.setRenderTarget(null)},this._width=t.width,this._height=t.height,this._type=t.type,this._colorSpace=t.colorSpace;const P={format:Nt,depthBuffer:!1,stencilBuffer:!1,type:this._type,colorSpace:this._colorSpace,anisotropy:((r=t.renderTargetOptions)===null||r===void 0?void 0:r.anisotropy)!==void 0?(a=t.renderTargetOptions)===null||a===void 0?void 0:a.anisotropy:1,generateMipmaps:((s=t.renderTargetOptions)===null||s===void 0?void 0:s.generateMipmaps)!==void 0?(o=t.renderTargetOptions)===null||o===void 0?void 0:o.generateMipmaps:!1,magFilter:((l=t.renderTargetOptions)===null||l===void 0?void 0:l.magFilter)!==void 0?(u=t.renderTargetOptions)===null||u===void 0?void 0:u.magFilter:Re,minFilter:((d=t.renderTargetOptions)===null||d===void 0?void 0:d.minFilter)!==void 0?(m=t.renderTargetOptions)===null||m===void 0?void 0:m.minFilter:Re,samples:((v=t.renderTargetOptions)===null||v===void 0?void 0:v.samples)!==void 0?(E=t.renderTargetOptions)===null||E===void 0?void 0:E.samples:void 0,wrapS:((b=t.renderTargetOptions)===null||b===void 0?void 0:b.wrapS)!==void 0?(B=t.renderTargetOptions)===null||B===void 0?void 0:B.wrapS:st,wrapT:((Z=t.renderTargetOptions)===null||Z===void 0?void 0:Z.wrapT)!==void 0?(Y=t.renderTargetOptions)===null||Y===void 0?void 0:Y.wrapT:st};if(this._material=t.material,t.renderer?this._renderer=t.renderer:(this._renderer=_r.instantiateRenderer(),this._rendererIsDisposable=!0),this._scene=new qt,this._camera=new vr,this._camera.position.set(0,0,10),this._camera.left=-.5,this._camera.right=.5,this._camera.top=.5,this._camera.bottom=-.5,this._camera.updateProjectionMatrix(),!ca(this._type,this._renderer,this._camera,P)){let D;switch(this._type){case Be:D=this._renderer.extensions.has("EXT_color_buffer_float")?je:void 0;break}D!==void 0?(console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${je}`),this._type=D):(this._supportsReadPixels=!1,console.warn("This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown"))}this._quad=new Lt(new en,this._material),this._quad.geometry.computeBoundingBox(),this._scene.add(this._quad),this._renderTarget=new Ge(this.width,this.height,P),this._renderTarget.texture.mapping=((z=t.renderTargetOptions)===null||z===void 0?void 0:z.mapping)!==void 0?(G=t.renderTargetOptions)===null||G===void 0?void 0:G.mapping:Qt}static instantiateRenderer(){const t=new Yn;return t.setSize(128,128),t}toArray(){if(!this._supportsReadPixels)throw new Error("Can't read pixels in this browser");const t=mn(this._type,this._width,this._height);return this._renderer.readRenderTargetPixels(this._renderTarget,0,0,this._width,this._height,t),t}toDataTexture(t){const r=new Kn(this.toArray(),this.width,this.height,Nt,this._type,(t==null?void 0:t.mapping)||Qt,(t==null?void 0:t.wrapS)||st,(t==null?void 0:t.wrapT)||st,(t==null?void 0:t.magFilter)||Re,(t==null?void 0:t.minFilter)||Re,(t==null?void 0:t.anisotropy)||1,Pt);return r.generateMipmaps=(t==null?void 0:t.generateMipmaps)!==void 0?t==null?void 0:t.generateMipmaps:!1,r}disposeOnDemandRenderer(){this._renderer.setRenderTarget(null),this._rendererIsDisposable&&(this._renderer.dispose(),this._renderer.forceContextLoss())}dispose(t){this.disposeOnDemandRenderer(),t&&this.renderTarget.dispose(),this.material instanceof tt&&Object.values(this.material.uniforms).forEach(r=>{r.value instanceof ot&&r.value.dispose()}),Object.values(this.material).forEach(r=>{r instanceof ot&&r.dispose()}),this.material.dispose(),this._quad.geometry.dispose()}get width(){return this._width}set width(t){this._width=t,this._renderTarget.setSize(this._width,this._height)}get height(){return this._height}set height(t){this._height=t,this._renderTarget.setSize(this._width,this._height)}get renderer(){return this._renderer}get renderTarget(){return this._renderTarget}set renderTarget(t){this._renderTarget=t,this._width=t.width,this._height=t.height}get material(){return this._material}get type(){return this._type}get colorSpace(){return this._colorSpace}}const ua=`
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,da=`
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`;class ha extends tt{constructor({gamma:t,offsetHdr:r,offsetSdr:a,gainMapMin:s,gainMapMax:o,maxDisplayBoost:l,hdrCapacityMin:u,hdrCapacityMax:d,sdr:m,gainMap:v}){super({name:"GainMapDecoderMaterial",vertexShader:ua,fragmentShader:da,uniforms:{sdr:{value:m},gainMap:{value:v},gamma:{value:new Qe(1/t[0],1/t[1],1/t[2])},offsetHdr:{value:new Qe().fromArray(r)},offsetSdr:{value:new Qe().fromArray(a)},gainMapMin:{value:new Qe().fromArray(s)},gainMapMax:{value:new Qe().fromArray(o)},weightFactor:{value:(Math.log2(l)-u)/(d-u)}},blending:gt,depthTest:!1,depthWrite:!1}),this._maxDisplayBoost=l,this._hdrCapacityMin=u,this._hdrCapacityMax=d,this.needsUpdate=!0,this.uniformsNeedUpdate=!0}get sdr(){return this.uniforms.sdr.value}set sdr(t){this.uniforms.sdr.value=t}get gainMap(){return this.uniforms.gainMap.value}set gainMap(t){this.uniforms.gainMap.value=t}get offsetHdr(){return this.uniforms.offsetHdr.value.toArray()}set offsetHdr(t){this.uniforms.offsetHdr.value.fromArray(t)}get offsetSdr(){return this.uniforms.offsetSdr.value.toArray()}set offsetSdr(t){this.uniforms.offsetSdr.value.fromArray(t)}get gainMapMin(){return this.uniforms.gainMapMin.value.toArray()}set gainMapMin(t){this.uniforms.gainMapMin.value.fromArray(t)}get gainMapMax(){return this.uniforms.gainMapMax.value.toArray()}set gainMapMax(t){this.uniforms.gainMapMax.value.fromArray(t)}get gamma(){const t=this.uniforms.gamma.value;return[1/t.x,1/t.y,1/t.z]}set gamma(t){const r=this.uniforms.gamma.value;r.x=1/t[0],r.y=1/t[1],r.z=1/t[2]}get hdrCapacityMin(){return this._hdrCapacityMin}set hdrCapacityMin(t){this._hdrCapacityMin=t,this.calculateWeight()}get hdrCapacityMax(){return this._hdrCapacityMax}set hdrCapacityMax(t){this._hdrCapacityMax=t,this.calculateWeight()}get maxDisplayBoost(){return this._maxDisplayBoost}set maxDisplayBoost(t){this._maxDisplayBoost=Math.max(1,Math.min(65504,t)),this.calculateWeight()}calculateWeight(){const t=(Math.log2(this._maxDisplayBoost)-this._hdrCapacityMin)/(this._hdrCapacityMax-this._hdrCapacityMin);this.uniforms.weightFactor.value=Math.max(0,Math.min(1,t))}}class vn extends Error{}class gn extends Error{}const It=(e,t,r)=>{const a=new RegExp(`${t}="([^"]*)"`,"i").exec(e);if(a)return a[1];const s=new RegExp(`<${t}[^>]*>([\\s\\S]*?)</${t}>`,"i").exec(e);if(s){const o=s[1].match(/<rdf:li>([^<]*)<\/rdf:li>/g);return o&&o.length===3?o.map(l=>l.replace(/<\/?rdf:li>/g,"")):s[1].trim()}if(r!==void 0)return r;throw new Error(`Can't find ${t} in gainmap metadata`)},fa=e=>{let t;typeof TextDecoder<"u"?t=new TextDecoder().decode(e):t=e.toString();let r=t.indexOf("<x:xmpmeta");for(;r!==-1;){const a=t.indexOf("x:xmpmeta>",r),s=t.slice(r,a+10);try{const o=It(s,"hdrgm:GainMapMin","0"),l=It(s,"hdrgm:GainMapMax"),u=It(s,"hdrgm:Gamma","1"),d=It(s,"hdrgm:OffsetSDR","0.015625"),m=It(s,"hdrgm:OffsetHDR","0.015625"),v=/hdrgm:HDRCapacityMin="([^"]*)"/.exec(s),E=v?v[1]:"0",b=/hdrgm:HDRCapacityMax="([^"]*)"/.exec(s);if(!b)throw new Error("Incomplete gainmap metadata");const B=b[1];return{gainMapMin:Array.isArray(o)?o.map(Z=>parseFloat(Z)):[parseFloat(o),parseFloat(o),parseFloat(o)],gainMapMax:Array.isArray(l)?l.map(Z=>parseFloat(Z)):[parseFloat(l),parseFloat(l),parseFloat(l)],gamma:Array.isArray(u)?u.map(Z=>parseFloat(Z)):[parseFloat(u),parseFloat(u),parseFloat(u)],offsetSdr:Array.isArray(d)?d.map(Z=>parseFloat(Z)):[parseFloat(d),parseFloat(d),parseFloat(d)],offsetHdr:Array.isArray(m)?m.map(Z=>parseFloat(Z)):[parseFloat(m),parseFloat(m),parseFloat(m)],hdrCapacityMin:parseFloat(E),hdrCapacityMax:parseFloat(B)}}catch{}r=t.indexOf("<x:xmpmeta",a)}};class pa{constructor(t){this.options={debug:t&&t.debug!==void 0?t.debug:!1,extractFII:t&&t.extractFII!==void 0?t.extractFII:!0,extractNonFII:t&&t.extractNonFII!==void 0?t.extractNonFII:!0}}extract(t){return new Promise((r,a)=>{const s=this.options.debug,o=new DataView(t.buffer);if(o.getUint16(0)!==65496){a(new Error("Not a valid jpeg"));return}const l=o.byteLength;let u=2,d=0,m;for(;u<l;){if(++d>250){a(new Error(`Found no marker after ${d} loops `));return}if(o.getUint8(u)!==255){a(new Error(`Not a valid marker at offset 0x${u.toString(16)}, found: 0x${o.getUint8(u).toString(16)}`));return}if(m=o.getUint8(u+1),s&&console.log(`Marker: ${m.toString(16)}`),m===226){s&&console.log("Found APP2 marker (0xffe2)");const v=u+4;if(o.getUint32(v)===1297106432){const E=v+4;let b;if(o.getUint16(E)===18761)b=!1;else if(o.getUint16(E)===19789)b=!0;else{a(new Error("No valid endianness marker found in TIFF header"));return}if(o.getUint16(E+2,!b)!==42){a(new Error("Not valid TIFF data! (no 0x002A marker)"));return}const B=o.getUint32(E+4,!b);if(B<8){a(new Error("Not valid TIFF data! (First offset less than 8)"));return}const Z=E+B,Y=o.getUint16(Z,!b),z=Z+2;let G=0;for(let V=z;V<z+12*Y;V+=12)o.getUint16(V,!b)===45057&&(G=o.getUint32(V+8,!b));const D=Z+2+Y*12+4,K=[];for(let V=D;V<D+G*16;V+=16){const L={MPType:o.getUint32(V,!b),size:o.getUint32(V+4,!b),dataOffset:o.getUint32(V+8,!b),dependantImages:o.getUint32(V+12,!b),start:-1,end:-1,isFII:!1};L.dataOffset?(L.start=E+L.dataOffset,L.isFII=!1):(L.start=0,L.isFII=!0),L.end=L.start+L.size,K.push(L)}if(this.options.extractNonFII&&K.length){const V=new Blob([o]),L=[];for(const ne of K){if(ne.isFII&&!this.options.extractFII)continue;const _=V.slice(ne.start,ne.end+1,"image/jpeg");L.push(_)}r(L)}}}u+=2+o.getUint16(u+2)}})}}const ma=async e=>{const t=fa(e);if(!t)throw new gn("Gain map XMP metadata not found");const a=await new pa({extractFII:!0,extractNonFII:!0}).extract(e);if(a.length!==2)throw new vn("Gain map recovery image not found");return{sdr:new Uint8Array(await a[0].arrayBuffer()),gainMap:new Uint8Array(await a[1].arrayBuffer()),metadata:t}},zr=e=>new Promise((t,r)=>{const a=document.createElement("img");a.onload=()=>{t(a)},a.onerror=s=>{r(s)},a.src=URL.createObjectURL(e)});class En extends ei{constructor(t,r){super(r),t&&(this._renderer=t),this._internalLoadingManager=new ti}setRenderer(t){return this._renderer=t,this}setRenderTargetOptions(t){return this._renderTargetOptions=t,this}prepareQuadRenderer(){this._renderer||console.warn("WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.");const t=new ha({gainMapMax:[1,1,1],gainMapMin:[0,0,0],gamma:[1,1,1],offsetHdr:[1,1,1],offsetSdr:[1,1,1],hdrCapacityMax:1,hdrCapacityMin:0,maxDisplayBoost:1,gainMap:new ot,sdr:new ot});return new _r({width:16,height:16,type:Be,colorSpace:Pt,material:t,renderer:this._renderer,renderTargetOptions:this._renderTargetOptions})}async render(t,r,a,s){const o=s?new Blob([s],{type:"image/jpeg"}):void 0,l=new Blob([a],{type:"image/jpeg"});let u,d,m=!1;if(typeof createImageBitmap>"u"){const b=await Promise.all([o?zr(o):Promise.resolve(void 0),zr(l)]);d=b[0],u=b[1],m=!0}else{const b=await Promise.all([o?createImageBitmap(o,{imageOrientation:"flipY"}):Promise.resolve(void 0),createImageBitmap(l,{imageOrientation:"flipY"})]);d=b[0],u=b[1]}const v=new ot(d||new ImageData(2,2),Qt,st,st,Re,Dr,Nt,ct,1,Pt);v.flipY=m,v.needsUpdate=!0;const E=new ot(u,Qt,st,st,Re,Dr,Nt,ct,1,$e);E.flipY=m,E.needsUpdate=!0,t.width=u.width,t.height=u.height,t.material.gainMap=v,t.material.sdr=E,t.material.gainMapMin=r.gainMapMin,t.material.gainMapMax=r.gainMapMax,t.material.offsetHdr=r.offsetHdr,t.material.offsetSdr=r.offsetSdr,t.material.gamma=r.gamma,t.material.hdrCapacityMin=r.hdrCapacityMin,t.material.hdrCapacityMax=r.hdrCapacityMax,t.material.maxDisplayBoost=Math.pow(2,r.hdrCapacityMax),t.material.needsUpdate=!0,t.render()}}class va extends En{load([t,r,a],s,o,l){const u=this.prepareQuadRenderer();let d,m,v;const E=async()=>{if(d&&m&&v){try{await this.render(u,v,d,m)}catch(S){this.manager.itemError(t),this.manager.itemError(r),this.manager.itemError(a),typeof l=="function"&&l(S),u.disposeOnDemandRenderer();return}typeof s=="function"&&s(u),this.manager.itemEnd(t),this.manager.itemEnd(r),this.manager.itemEnd(a),u.disposeOnDemandRenderer()}};let b=!0,B=0,Z=0,Y=!0,z=0,G=0,P=!0,D=0,K=0;const V=()=>{if(typeof o=="function"){const S=B+z+D,U=Z+G+K,A=b&&Y&&P;o(new ProgressEvent("progress",{lengthComputable:A,loaded:U,total:S}))}};this.manager.itemStart(t),this.manager.itemStart(r),this.manager.itemStart(a);const L=new Kt(this._internalLoadingManager);L.setResponseType("arraybuffer"),L.setRequestHeader(this.requestHeader),L.setPath(this.path),L.setWithCredentials(this.withCredentials),L.load(t,async S=>{if(typeof S=="string")throw new Error("Invalid sdr buffer");d=S,await E()},S=>{b=S.lengthComputable,Z=S.loaded,B=S.total,V()},S=>{this.manager.itemError(t),typeof l=="function"&&l(S)});const ne=new Kt(this._internalLoadingManager);ne.setResponseType("arraybuffer"),ne.setRequestHeader(this.requestHeader),ne.setPath(this.path),ne.setWithCredentials(this.withCredentials),ne.load(r,async S=>{if(typeof S=="string")throw new Error("Invalid gainmap buffer");m=S,await E()},S=>{Y=S.lengthComputable,G=S.loaded,z=S.total,V()},S=>{this.manager.itemError(r),typeof l=="function"&&l(S)});const _=new Kt(this._internalLoadingManager);return _.setRequestHeader(this.requestHeader),_.setPath(this.path),_.setWithCredentials(this.withCredentials),_.load(a,async S=>{if(typeof S!="string")throw new Error("Invalid metadata string");v=JSON.parse(S),await E()},S=>{P=S.lengthComputable,K=S.loaded,D=S.total,V()},S=>{this.manager.itemError(a),typeof l=="function"&&l(S)}),u}}class ga extends En{load(t,r,a,s){const o=this.prepareQuadRenderer(),l=new Kt(this._internalLoadingManager);return l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setPath(this.path),l.setWithCredentials(this.withCredentials),this.manager.itemStart(t),l.load(t,async u=>{if(typeof u=="string")throw new Error("Invalid buffer, received [string], was expecting [ArrayBuffer]");const d=new Uint8Array(u);let m,v,E;try{const b=await ma(d);m=b.sdr,v=b.gainMap,E=b.metadata}catch(b){if(b instanceof gn||b instanceof vn)console.warn(`Failure to reconstruct an HDR image from ${t}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`),E={gainMapMin:[0,0,0],gainMapMax:[1,1,1],gamma:[1,1,1],hdrCapacityMin:0,hdrCapacityMax:1,offsetHdr:[0,0,0],offsetSdr:[0,0,0]},m=d;else throw b}try{await this.render(o,E,m,v)}catch(b){this.manager.itemError(t),typeof s=="function"&&s(b),o.disposeOnDemandRenderer();return}typeof r=="function"&&r(o),this.manager.itemEnd(t),o.disposeOnDemandRenderer()},a,u=>{this.manager.itemError(t),typeof s=="function"&&s(u)}),o}}const Ot={apartment:"lebombo_1k.hdr",city:"potsdamer_platz_1k.hdr",dawn:"kiara_1_dawn_1k.hdr",forest:"forest_slope_1k.hdr",lobby:"st_fagans_interior_1k.hdr",night:"dikhololo_night_1k.hdr",park:"rooitou_park_1k.hdr",studio:"studio_small_03_1k.hdr",sunset:"venice_sunset_1k.hdr",warehouse:"empty_warehouse_01_1k.hdr"},Sn="https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/",mt=e=>Array.isArray(e),wr=["/px.png","/nx.png","/py.png","/ny.png","/pz.png","/nz.png"];function tr({files:e=wr,path:t="",preset:r=void 0,encoding:a=void 0,extensions:s}={}){let o=null,l=!1;r&&(Tr(r),e=Ot[r],t=Sn),l=mt(e);const{extension:u,isCubemap:d}=Mr(e);if(o=yr(u),!o)throw new Error("useEnvironment: Unrecognized file extension: "+e);const m=ze(B=>B.gl);R.useLayoutEffect(()=>{if(u!=="webp"&&u!=="jpg"&&u!=="jpeg")return;function B(){Jt.clear(o,l?[e]:e)}m.domElement.addEventListener("webglcontextlost",B,{once:!0})},[e,m.domElement]);const v=Jt(o,l?[e]:e,B=>{(u==="webp"||u==="jpg"||u==="jpeg")&&B.setRenderer(m),B.setPath==null||B.setPath(t),s&&s(B)});let E=l?v[0]:v;if(u==="jpg"||u==="jpeg"||u==="webp"){var b;E=(b=E.renderTarget)==null?void 0:b.texture}return E.mapping=d?ri:ni,"colorSpace"in E?E.colorSpace=a??d?"srgb":"srgb-linear":E.encoding=a??d?oa:sa,E}const Ea={files:wr,path:"",preset:void 0,extensions:void 0};tr.preload=e=>{const t={...Ea,...e};let{files:r,path:a=""}=t;const{preset:s,extensions:o}=t;s&&(Tr(s),r=Ot[s],a=Sn);const{extension:l}=Mr(r);if(l==="webp"||l==="jpg"||l==="jpeg")throw new Error("useEnvironment: Preloading gainmaps is not supported");const u=yr(l);if(!u)throw new Error("useEnvironment: Unrecognized file extension: "+r);Jt.preload(u,mt(r)?[r]:r,d=>{d.setPath==null||d.setPath(a),o&&o(d)})};const Sa={files:wr,preset:void 0};tr.clear=e=>{const t={...Sa,...e};let{files:r}=t;const{preset:a}=t;a&&(Tr(a),r=Ot[a]);const{extension:s}=Mr(r),o=yr(s);if(!o)throw new Error("useEnvironment: Unrecognized file extension: "+r);Jt.clear(o,mt(r)?[r]:r)};function Tr(e){if(!(e in Ot))throw new Error("Preset must be one of: "+Object.keys(Ot).join(", "))}function Mr(e){var t;const r=mt(e)&&e.length===6,a=mt(e)&&e.length===3&&e.some(l=>l.endsWith("json")),s=mt(e)?e[0]:e;return{extension:r?"cube":a?"webp":s.startsWith("data:application/exr")?"exr":s.startsWith("data:application/hdr")?"hdr":s.startsWith("data:image/jpeg")?"jpg":(t=s.split(".").pop())==null||(t=t.split("?"))==null||(t=t.shift())==null?void 0:t.toLowerCase(),isCubemap:r,isGainmap:a}}function yr(e){return e==="cube"?ii:e==="hdr"?ia:e==="exr"?aa:e==="jpg"||e==="jpeg"?ga:e==="webp"?va:null}const xa=e=>e.current&&e.current.isScene,_a=e=>xa(e)?e.current:e;function Rr(e,t,r,a,s={}){var o,l,u,d;s={backgroundBlurriness:0,backgroundIntensity:1,backgroundRotation:[0,0,0],environmentIntensity:1,environmentRotation:[0,0,0],...s};const m=_a(t||r),v=m.background,E=m.environment,b={backgroundBlurriness:m.backgroundBlurriness,backgroundIntensity:m.backgroundIntensity,backgroundRotation:(o=(l=m.backgroundRotation)==null||l.clone==null?void 0:l.clone())!==null&&o!==void 0?o:[0,0,0],environmentIntensity:m.environmentIntensity,environmentRotation:(u=(d=m.environmentRotation)==null||d.clone==null?void 0:d.clone())!==null&&u!==void 0?u:[0,0,0]};return e!=="only"&&(m.environment=a),e&&(m.background=a),Nr(m,s),()=>{e!=="only"&&(m.environment=E),e&&(m.background=v),Nr(m,b)}}function br({scene:e,background:t=!1,map:r,...a}){const s=ze(o=>o.scene);return R.useLayoutEffect(()=>{if(r)return Rr(t,e,s,r,a)}),null}function xn({background:e=!1,scene:t,blur:r,backgroundBlurriness:a,backgroundIntensity:s,backgroundRotation:o,environmentIntensity:l,environmentRotation:u,...d}){const m=tr(d),v=ze(E=>E.scene);return R.useLayoutEffect(()=>Rr(e,t,v,m,{backgroundBlurriness:r??a,backgroundIntensity:s,backgroundRotation:o,environmentIntensity:l,environmentRotation:u})),R.useEffect(()=>()=>{m.dispose()},[m]),null}function wa({children:e,near:t=.1,far:r=1e3,resolution:a=256,frames:s=1,map:o,background:l=!1,blur:u,backgroundBlurriness:d,backgroundIntensity:m,backgroundRotation:v,environmentIntensity:E,environmentRotation:b,scene:B,files:Z,path:Y,preset:z=void 0,extensions:G}){const P=ze(_=>_.gl),D=ze(_=>_.scene),K=R.useRef(null),[V]=R.useState(()=>new qt),L=R.useMemo(()=>{const _=new ai(a);return _.texture.type=Be,_},[a]);R.useEffect(()=>()=>{L.dispose()},[L]),R.useLayoutEffect(()=>{if(s===1){const _=P.autoClear;P.autoClear=!0,K.current.update(P,V),P.autoClear=_}return Rr(l,B,D,L.texture,{backgroundBlurriness:u??d,backgroundIntensity:m,backgroundRotation:v,environmentIntensity:E,environmentRotation:b})},[e,V,L.texture,B,D,l,s,P]);let ne=1;return mr(()=>{if(s===1/0||ne<s){const _=P.autoClear;P.autoClear=!0,K.current.update(P,V),P.autoClear=_,ne++}}),R.createElement(R.Fragment,null,si(R.createElement(R.Fragment,null,e,R.createElement("cubeCamera",{ref:K,args:[t,r,L]}),Z||z?R.createElement(xn,{background:!0,files:Z,preset:z,path:Y,extensions:G}):o?R.createElement(br,{background:!0,map:o,extensions:G}):null),V))}function Ta(e){var t,r,a,s;const o=tr(e),l=e.map||o;R.useMemo(()=>nn({GroundProjectedEnvImpl:na}),[]),R.useEffect(()=>()=>{o.dispose()},[o]);const u=R.useMemo(()=>[l],[l]),d=(t=e.ground)==null?void 0:t.height,m=(r=e.ground)==null?void 0:r.radius,v=(a=(s=e.ground)==null?void 0:s.scale)!==null&&a!==void 0?a:1e3;return R.createElement(R.Fragment,null,R.createElement(br,qr({},e,{map:l})),R.createElement("groundProjectedEnvImpl",{args:u,scale:v,height:d,radius:m}))}function Hs(e){return e.ground?R.createElement(Ta,e):e.map?R.createElement(br,e):e.children?R.createElement(wa,e):R.createElement(xn,e)}/**
 * postprocessing v6.36.6 build Tue Dec 31 2024
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2024 Raoul van Rschen
 * @license Zlib
 */var cr=1/1e3,Ma=1e3,ya=class{constructor(){this.startTime=performance.now(),this.previousTime=0,this.currentTime=0,this._delta=0,this._elapsed=0,this._fixedDelta=1e3/60,this.timescale=1,this.useFixedDelta=!1,this._autoReset=!1}get autoReset(){return this._autoReset}set autoReset(e){typeof document<"u"&&document.hidden!==void 0&&(e?document.addEventListener("visibilitychange",this):document.removeEventListener("visibilitychange",this),this._autoReset=e)}get delta(){return this._delta*cr}get fixedDelta(){return this._fixedDelta*cr}set fixedDelta(e){this._fixedDelta=e*Ma}get elapsed(){return this._elapsed*cr}update(e){this.useFixedDelta?this._delta=this.fixedDelta:(this.previousTime=this.currentTime,this.currentTime=(e!==void 0?e:performance.now())-this.startTime,this._delta=this.currentTime-this.previousTime),this._delta*=this.timescale,this._elapsed+=this._delta}reset(){this._delta=0,this._elapsed=0,this.currentTime=performance.now()-this.startTime}getDelta(){return this.delta}getElapsed(){return this.elapsed}handleEvent(e){document.hidden||(this.currentTime=performance.now()-this.startTime)}dispose(){this.autoReset=!1}},Ra=(()=>{const e=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),t=new Float32Array([0,0,2,0,0,2]),r=new pi;return r.setAttribute("position",new Pr(e,3)),r.setAttribute("uv",new Pr(t,2)),r})(),De=class pr{static get fullscreenGeometry(){return Ra}constructor(t="Pass",r=new qt,a=new di){this.name=t,this.renderer=null,this.scene=r,this.camera=a,this.screen=null,this.rtt=!0,this.needsSwap=!0,this.needsDepthTexture=!1,this.enabled=!0}get renderToScreen(){return!this.rtt}set renderToScreen(t){if(this.rtt===t){const r=this.fullscreenMaterial;r!==null&&(r.needsUpdate=!0),this.rtt=!t}}set mainScene(t){}set mainCamera(t){}setRenderer(t){this.renderer=t}isEnabled(){return this.enabled}setEnabled(t){this.enabled=t}get fullscreenMaterial(){return this.screen!==null?this.screen.material:null}set fullscreenMaterial(t){let r=this.screen;r!==null?r.material=t:(r=new Lt(pr.fullscreenGeometry,t),r.frustumCulled=!1,this.scene===null&&(this.scene=new qt),this.scene.add(r),this.screen=r)}getFullscreenMaterial(){return this.fullscreenMaterial}setFullscreenMaterial(t){this.fullscreenMaterial=t}getDepthTexture(){return null}setDepthTexture(t,r=Et){}render(t,r,a,s,o){throw new Error("Render method not implemented!")}setSize(t,r){}initialize(t,r,a){}dispose(){for(const t of Object.keys(this)){const r=this[t];(r instanceof Ge||r instanceof on||r instanceof ot||r instanceof pr)&&this[t].dispose()}this.fullscreenMaterial!==null&&this.fullscreenMaterial.dispose()}},ba=class extends De{constructor(){super("ClearMaskPass",null,null),this.needsSwap=!1}render(e,t,r,a,s){const o=e.state.buffers.stencil;o.setLocked(!1),o.setTest(!1)}},Ca=`#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <colorspace_fragment>
#include <dithering_fragment>
}`,Cr="varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",Ia=class extends tt{constructor(){super({name:"CopyMaterial",uniforms:{inputBuffer:new re(null),opacity:new re(1)},blending:gt,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:Ca,vertexShader:Cr})}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}getOpacity(e){return this.uniforms.opacity.value}setOpacity(e){this.uniforms.opacity.value=e}},_n=class extends De{constructor(e,t=!0){super("CopyPass"),this.fullscreenMaterial=new Ia,this.needsSwap=!1,this.renderTarget=e,e===void 0&&(this.renderTarget=new Ge(1,1,{minFilter:Re,magFilter:Re,stencilBuffer:!1,depthBuffer:!1}),this.renderTarget.texture.name="CopyPass.Target"),this.autoResize=t}get resize(){return this.autoResize}set resize(e){this.autoResize=e}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}setAutoResizeEnabled(e){this.autoResize=e}render(e,t,r,a,s){this.fullscreenMaterial.inputBuffer=t.texture,e.setRenderTarget(this.renderToScreen?null:this.renderTarget),e.render(this.scene,this.camera)}setSize(e,t){this.autoResize&&this.renderTarget.setSize(e,t)}initialize(e,t,r){r!==void 0&&(this.renderTarget.texture.type=r,r!==ct?this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1":e!==null&&e.outputColorSpace===$e&&(this.renderTarget.texture.colorSpace=$e))}},kr=new sn,wn=class extends De{constructor(e=!0,t=!0,r=!1){super("ClearPass",null,null),this.needsSwap=!1,this.color=e,this.depth=t,this.stencil=r,this.overrideClearColor=null,this.overrideClearAlpha=-1}setClearFlags(e,t,r){this.color=e,this.depth=t,this.stencil=r}getOverrideClearColor(){return this.overrideClearColor}setOverrideClearColor(e){this.overrideClearColor=e}getOverrideClearAlpha(){return this.overrideClearAlpha}setOverrideClearAlpha(e){this.overrideClearAlpha=e}render(e,t,r,a,s){const o=this.overrideClearColor,l=this.overrideClearAlpha,u=e.getClearAlpha(),d=o!==null,m=l>=0;d?(e.getClearColor(kr),e.setClearColor(o,m?l:u)):m&&e.setClearAlpha(l),e.setRenderTarget(this.renderToScreen?null:t),e.clear(this.color,this.depth,this.stencil),d?e.setClearColor(kr,u):m&&e.setClearAlpha(u)}},Aa=class extends De{constructor(e,t){super("MaskPass",e,t),this.needsSwap=!1,this.clearPass=new wn(!1,!1,!0),this.inverse=!1}set mainScene(e){this.scene=e}set mainCamera(e){this.camera=e}get inverted(){return this.inverse}set inverted(e){this.inverse=e}get clear(){return this.clearPass.enabled}set clear(e){this.clearPass.enabled=e}getClearPass(){return this.clearPass}isInverted(){return this.inverted}setInverted(e){this.inverted=e}render(e,t,r,a,s){const o=e.getContext(),l=e.state.buffers,u=this.scene,d=this.camera,m=this.clearPass,v=this.inverted?0:1,E=1-v;l.color.setMask(!1),l.depth.setMask(!1),l.color.setLocked(!0),l.depth.setLocked(!0),l.stencil.setTest(!0),l.stencil.setOp(o.REPLACE,o.REPLACE,o.REPLACE),l.stencil.setFunc(o.ALWAYS,v,4294967295),l.stencil.setClear(E),l.stencil.setLocked(!0),this.clearPass.enabled&&(this.renderToScreen?m.render(e,null):(m.render(e,t),m.render(e,r))),this.renderToScreen?(e.setRenderTarget(null),e.render(u,d)):(e.setRenderTarget(t),e.render(u,d),e.setRenderTarget(r),e.render(u,d)),l.color.setLocked(!1),l.depth.setLocked(!1),l.stencil.setLocked(!1),l.stencil.setFunc(o.EQUAL,1,4294967295),l.stencil.setOp(o.KEEP,o.KEEP,o.KEEP),l.stencil.setLocked(!0)}},Ba=class{constructor(t=null,{depthBuffer:r=!0,stencilBuffer:a=!1,multisampling:s=0,frameBufferType:o}={}){this.renderer=null,this.inputBuffer=this.createBuffer(r,a,o,s),this.outputBuffer=this.inputBuffer.clone(),this.copyPass=new _n,this.depthTexture=null,this.passes=[],this.timer=new ya,this.autoRenderToScreen=!0,this.setRenderer(t)}get multisampling(){return this.inputBuffer.samples||0}set multisampling(t){const r=this.inputBuffer,a=this.multisampling;a>0&&t>0?(this.inputBuffer.samples=t,this.outputBuffer.samples=t,this.inputBuffer.dispose(),this.outputBuffer.dispose()):a!==t&&(this.inputBuffer.dispose(),this.outputBuffer.dispose(),this.inputBuffer=this.createBuffer(r.depthBuffer,r.stencilBuffer,r.texture.type,t),this.inputBuffer.depthTexture=this.depthTexture,this.outputBuffer=this.inputBuffer.clone())}getTimer(){return this.timer}getRenderer(){return this.renderer}setRenderer(t){if(this.renderer=t,t!==null){const r=t.getSize(new Ie),a=t.getContext().getContextAttributes().alpha,s=this.inputBuffer.texture.type;s===ct&&t.outputColorSpace===$e&&(this.inputBuffer.texture.colorSpace=$e,this.outputBuffer.texture.colorSpace=$e,this.inputBuffer.dispose(),this.outputBuffer.dispose()),t.autoClear=!1,this.setSize(r.width,r.height);for(const o of this.passes)o.initialize(t,a,s)}}replaceRenderer(t,r=!0){const a=this.renderer,s=a.domElement.parentNode;return this.setRenderer(t),r&&s!==null&&(s.removeChild(a.domElement),s.appendChild(t.domElement)),a}createDepthTexture(){const t=this.depthTexture=new oi;return this.inputBuffer.depthTexture=t,this.inputBuffer.dispose(),this.inputBuffer.stencilBuffer?(t.format=li,t.type=ci):t.type=tn,t}deleteDepthTexture(){if(this.depthTexture!==null){this.depthTexture.dispose(),this.depthTexture=null,this.inputBuffer.depthTexture=null,this.inputBuffer.dispose();for(const t of this.passes)t.setDepthTexture(null)}}createBuffer(t,r,a,s){const o=this.renderer,l=o===null?new Ie:o.getDrawingBufferSize(new Ie),u={minFilter:Re,magFilter:Re,stencilBuffer:r,depthBuffer:t,type:a},d=new Ge(l.width,l.height,u);return s>0&&(d.ignoreDepthForMultisampleCopy=!1,d.samples=s),a===ct&&o!==null&&o.outputColorSpace===$e&&(d.texture.colorSpace=$e),d.texture.name="EffectComposer.Buffer",d.texture.generateMipmaps=!1,d}setMainScene(t){for(const r of this.passes)r.mainScene=t}setMainCamera(t){for(const r of this.passes)r.mainCamera=t}addPass(t,r){const a=this.passes,s=this.renderer,o=s.getDrawingBufferSize(new Ie),l=s.getContext().getContextAttributes().alpha,u=this.inputBuffer.texture.type;if(t.setRenderer(s),t.setSize(o.width,o.height),t.initialize(s,l,u),this.autoRenderToScreen&&(a.length>0&&(a[a.length-1].renderToScreen=!1),t.renderToScreen&&(this.autoRenderToScreen=!1)),r!==void 0?a.splice(r,0,t):a.push(t),this.autoRenderToScreen&&(a[a.length-1].renderToScreen=!0),t.needsDepthTexture||this.depthTexture!==null)if(this.depthTexture===null){const d=this.createDepthTexture();for(t of a)t.setDepthTexture(d)}else t.setDepthTexture(this.depthTexture)}removePass(t){const r=this.passes,a=r.indexOf(t);if(a!==-1&&r.splice(a,1).length>0){if(this.depthTexture!==null){const l=(d,m)=>d||m.needsDepthTexture;r.reduce(l,!1)||(t.getDepthTexture()===this.depthTexture&&t.setDepthTexture(null),this.deleteDepthTexture())}this.autoRenderToScreen&&a===r.length&&(t.renderToScreen=!1,r.length>0&&(r[r.length-1].renderToScreen=!0))}}removeAllPasses(){const t=this.passes;this.deleteDepthTexture(),t.length>0&&(this.autoRenderToScreen&&(t[t.length-1].renderToScreen=!1),this.passes=[])}render(t){const r=this.renderer,a=this.copyPass;let s=this.inputBuffer,o=this.outputBuffer,l=!1,u,d,m;t===void 0&&(this.timer.update(),t=this.timer.getDelta());for(const v of this.passes)v.enabled&&(v.render(r,s,o,t,l),v.needsSwap&&(l&&(a.renderToScreen=v.renderToScreen,u=r.getContext(),d=r.state.buffers.stencil,d.setFunc(u.NOTEQUAL,1,4294967295),a.render(r,s,o,t,l),d.setFunc(u.EQUAL,1,4294967295)),m=s,s=o,o=m),v instanceof Aa?l=!0:v instanceof ba&&(l=!1))}setSize(t,r,a){const s=this.renderer,o=s.getSize(new Ie);(t===void 0||r===void 0)&&(t=o.width,r=o.height),(o.width!==t||o.height!==r)&&s.setSize(t,r,a);const l=s.getDrawingBufferSize(new Ie);this.inputBuffer.setSize(l.width,l.height),this.outputBuffer.setSize(l.width,l.height);for(const u of this.passes)u.setSize(l.width,l.height)}reset(){this.dispose(),this.autoRenderToScreen=!0}dispose(){for(const t of this.passes)t.dispose();this.passes=[],this.inputBuffer!==null&&this.inputBuffer.dispose(),this.outputBuffer!==null&&this.outputBuffer.dispose(),this.deleteDepthTexture(),this.copyPass.dispose(),this.timer.dispose(),De.fullscreenGeometry.dispose()}},Je={NONE:0,DEPTH:1,CONVOLUTION:2},Q={FRAGMENT_HEAD:"FRAGMENT_HEAD",FRAGMENT_MAIN_UV:"FRAGMENT_MAIN_UV",FRAGMENT_MAIN_IMAGE:"FRAGMENT_MAIN_IMAGE",VERTEX_HEAD:"VERTEX_HEAD",VERTEX_MAIN_SUPPORT:"VERTEX_MAIN_SUPPORT"},Da=class{constructor(){this.shaderParts=new Map([[Q.FRAGMENT_HEAD,null],[Q.FRAGMENT_MAIN_UV,null],[Q.FRAGMENT_MAIN_IMAGE,null],[Q.VERTEX_HEAD,null],[Q.VERTEX_MAIN_SUPPORT,null]]),this.defines=new Map,this.uniforms=new Map,this.blendModes=new Map,this.extensions=new Set,this.attributes=Je.NONE,this.varyings=new Set,this.uvTransformation=!1,this.readDepth=!1,this.colorSpace=Pt}},ur=!1,Hr=class{constructor(e=null){this.originalMaterials=new Map,this.material=null,this.materials=null,this.materialsBackSide=null,this.materialsDoubleSide=null,this.materialsFlatShaded=null,this.materialsFlatShadedBackSide=null,this.materialsFlatShadedDoubleSide=null,this.setMaterial(e),this.meshCount=0,this.replaceMaterial=t=>{if(t.isMesh){let r;if(t.material.flatShading)switch(t.material.side){case ft:r=this.materialsFlatShadedDoubleSide;break;case jt:r=this.materialsFlatShadedBackSide;break;default:r=this.materialsFlatShaded;break}else switch(t.material.side){case ft:r=this.materialsDoubleSide;break;case jt:r=this.materialsBackSide;break;default:r=this.materials;break}this.originalMaterials.set(t,t.material),t.isSkinnedMesh?t.material=r[2]:t.isInstancedMesh?t.material=r[1]:t.material=r[0],++this.meshCount}}}cloneMaterial(e){if(!(e instanceof tt))return e.clone();const t=e.uniforms,r=new Map;for(const s in t){const o=t[s].value;o.isRenderTargetTexture&&(t[s].value=null,r.set(s,o))}const a=e.clone();for(const s of r)t[s[0]].value=s[1],a.uniforms[s[0]].value=s[1];return a}setMaterial(e){if(this.disposeMaterials(),this.material=e,e!==null){const t=this.materials=[this.cloneMaterial(e),this.cloneMaterial(e),this.cloneMaterial(e)];for(const r of t)r.uniforms=Object.assign({},e.uniforms),r.side=hi;t[2].skinning=!0,this.materialsBackSide=t.map(r=>{const a=this.cloneMaterial(r);return a.uniforms=Object.assign({},e.uniforms),a.side=jt,a}),this.materialsDoubleSide=t.map(r=>{const a=this.cloneMaterial(r);return a.uniforms=Object.assign({},e.uniforms),a.side=ft,a}),this.materialsFlatShaded=t.map(r=>{const a=this.cloneMaterial(r);return a.uniforms=Object.assign({},e.uniforms),a.flatShading=!0,a}),this.materialsFlatShadedBackSide=t.map(r=>{const a=this.cloneMaterial(r);return a.uniforms=Object.assign({},e.uniforms),a.flatShading=!0,a.side=jt,a}),this.materialsFlatShadedDoubleSide=t.map(r=>{const a=this.cloneMaterial(r);return a.uniforms=Object.assign({},e.uniforms),a.flatShading=!0,a.side=ft,a})}}render(e,t,r){const a=e.shadowMap.enabled;if(e.shadowMap.enabled=!1,ur){const s=this.originalMaterials;this.meshCount=0,t.traverse(this.replaceMaterial),e.render(t,r);for(const o of s)o[0].material=o[1];this.meshCount!==s.size&&s.clear()}else{const s=t.overrideMaterial;t.overrideMaterial=this.material,e.render(t,r),t.overrideMaterial=s}e.shadowMap.enabled=a}disposeMaterials(){if(this.material!==null){const e=this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);for(const t of e)t.dispose()}}dispose(){this.originalMaterials.clear(),this.disposeMaterials()}static get workaroundEnabled(){return ur}static set workaroundEnabled(e){ur=e}},at=-1,et=class extends Er{constructor(e,t=at,r=at,a=1){super(),this.resizable=e,this.baseSize=new Ie(1,1),this.preferredSize=new Ie(t,r),this.target=this.preferredSize,this.s=a,this.effectiveSize=new Ie,this.addEventListener("change",()=>this.updateEffectiveSize()),this.updateEffectiveSize()}updateEffectiveSize(){const e=this.baseSize,t=this.preferredSize,r=this.effectiveSize,a=this.scale;t.width!==at?r.width=t.width:t.height!==at?r.width=Math.round(t.height*(e.width/Math.max(e.height,1))):r.width=Math.round(e.width*a),t.height!==at?r.height=t.height:t.width!==at?r.height=Math.round(t.width/Math.max(e.width/Math.max(e.height,1),1)):r.height=Math.round(e.height*a)}get width(){return this.effectiveSize.width}set width(e){this.preferredWidth=e}get height(){return this.effectiveSize.height}set height(e){this.preferredHeight=e}getWidth(){return this.width}getHeight(){return this.height}get scale(){return this.s}set scale(e){this.s!==e&&(this.s=e,this.preferredSize.setScalar(at),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getScale(){return this.scale}setScale(e){this.scale=e}get baseWidth(){return this.baseSize.width}set baseWidth(e){this.baseSize.width!==e&&(this.baseSize.width=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseWidth(){return this.baseWidth}setBaseWidth(e){this.baseWidth=e}get baseHeight(){return this.baseSize.height}set baseHeight(e){this.baseSize.height!==e&&(this.baseSize.height=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseHeight(){return this.baseHeight}setBaseHeight(e){this.baseHeight=e}setBaseSize(e,t){(this.baseSize.width!==e||this.baseSize.height!==t)&&(this.baseSize.set(e,t),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}get preferredWidth(){return this.preferredSize.width}set preferredWidth(e){this.preferredSize.width!==e&&(this.preferredSize.width=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredWidth(){return this.preferredWidth}setPreferredWidth(e){this.preferredWidth=e}get preferredHeight(){return this.preferredSize.height}set preferredHeight(e){this.preferredSize.height!==e&&(this.preferredSize.height=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredHeight(){return this.preferredHeight}setPreferredHeight(e){this.preferredHeight=e}setPreferredSize(e,t){(this.preferredSize.width!==e||this.preferredSize.height!==t)&&(this.preferredSize.set(e,t),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}copy(e){this.s=e.scale,this.baseSize.set(e.baseWidth,e.baseHeight),this.preferredSize.set(e.preferredWidth,e.preferredHeight),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height)}static get AUTO_SIZE(){return at}},X={SKIP:9,SET:30,ADD:0,ALPHA:1,AVERAGE:2,COLOR:3,COLOR_BURN:4,COLOR_DODGE:5,DARKEN:6,DIFFERENCE:7,DIVIDE:8,DST:9,EXCLUSION:10,HARD_LIGHT:11,HARD_MIX:12,HUE:13,INVERT:14,INVERT_RGB:15,LIGHTEN:16,LINEAR_BURN:17,LINEAR_DODGE:18,LINEAR_LIGHT:19,LUMINOSITY:20,MULTIPLY:21,NEGATION:22,NORMAL:23,OVERLAY:24,PIN_LIGHT:25,REFLECT:26,SATURATION:27,SCREEN:28,SOFT_LIGHT:29,SRC:30,SUBTRACT:31,VIVID_LIGHT:32},Na="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}",Pa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}",Oa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}",La="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",Fa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}",Ua="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}",za="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}",ka="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}",Ha="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}",Ga="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}",Va="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}",Wa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}",Za="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}",$a="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}",ja="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}",Xa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}",Ya="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}",Ka="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}",qa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}",Qa="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",Ja="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}",es="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}",ts="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}",rs="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}",ns="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}",is="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}",as="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",ss="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}",os="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}",ls="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}",cs="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}",us="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}",ds=new Map([[X.ADD,Na],[X.ALPHA,Pa],[X.AVERAGE,Oa],[X.COLOR,La],[X.COLOR_BURN,Fa],[X.COLOR_DODGE,Ua],[X.DARKEN,za],[X.DIFFERENCE,ka],[X.DIVIDE,Ha],[X.DST,null],[X.EXCLUSION,Ga],[X.HARD_LIGHT,Va],[X.HARD_MIX,Wa],[X.HUE,Za],[X.INVERT,$a],[X.INVERT_RGB,ja],[X.LIGHTEN,Xa],[X.LINEAR_BURN,Ya],[X.LINEAR_DODGE,Ka],[X.LINEAR_LIGHT,qa],[X.LUMINOSITY,Qa],[X.MULTIPLY,Ja],[X.NEGATION,es],[X.NORMAL,ts],[X.OVERLAY,rs],[X.PIN_LIGHT,ns],[X.REFLECT,is],[X.SATURATION,as],[X.SCREEN,ss],[X.SOFT_LIGHT,os],[X.SRC,ls],[X.SUBTRACT,cs],[X.VIVID_LIGHT,us]]),hs=class extends Er{constructor(e,t=1){super(),this._blendFunction=e,this.opacity=new re(t)}getOpacity(){return this.opacity.value}setOpacity(e){this.opacity.value=e}get blendFunction(){return this._blendFunction}set blendFunction(e){this._blendFunction=e,this.dispatchEvent({type:"change"})}getBlendFunction(){return this.blendFunction}setBlendFunction(e){this.blendFunction=e}getShaderCode(){return ds.get(this.blendFunction)}},fs=`#include <common>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);l*=low*high;
#elif defined(THRESHOLD)
l=smoothstep(threshold,threshold+smoothing,l)*l;
#endif
#ifdef COLOR
gl_FragColor=vec4(texel.rgb*clamp(l,0.0,1.0),l);
#else
gl_FragColor=vec4(l);
#endif
}`,ps=class extends tt{constructor(e=!1,t=null){super({name:"LuminanceMaterial",defines:{THREE_REVISION:Sr.replace(/\D+/g,"")},uniforms:{inputBuffer:new re(null),threshold:new re(0),smoothing:new re(1),range:new re(null)},blending:gt,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:fs,vertexShader:Cr}),this.colorOutput=e,this.luminanceRange=t}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}get threshold(){return this.uniforms.threshold.value}set threshold(e){this.smoothing>0||e>0?this.defines.THRESHOLD="1":delete this.defines.THRESHOLD,this.uniforms.threshold.value=e}getThreshold(){return this.threshold}setThreshold(e){this.threshold=e}get smoothing(){return this.uniforms.smoothing.value}set smoothing(e){this.threshold>0||e>0?this.defines.THRESHOLD="1":delete this.defines.THRESHOLD,this.uniforms.smoothing.value=e}getSmoothingFactor(){return this.smoothing}setSmoothingFactor(e){this.smoothing=e}get useThreshold(){return this.threshold>0||this.smoothing>0}set useThreshold(e){}get colorOutput(){return this.defines.COLOR!==void 0}set colorOutput(e){e?this.defines.COLOR="1":delete this.defines.COLOR,this.needsUpdate=!0}isColorOutputEnabled(e){return this.colorOutput}setColorOutputEnabled(e){this.colorOutput=e}get useRange(){return this.luminanceRange!==null}set useRange(e){this.luminanceRange=null}get luminanceRange(){return this.uniforms.range.value}set luminanceRange(e){e!==null?this.defines.RANGE="1":delete this.defines.RANGE,this.uniforms.range.value=e,this.needsUpdate=!0}getLuminanceRange(){return this.luminanceRange}setLuminanceRange(e){this.luminanceRange=e}},ms=class extends De{constructor({renderTarget:e,luminanceRange:t,colorOutput:r,resolutionScale:a=1,width:s=et.AUTO_SIZE,height:o=et.AUTO_SIZE,resolutionX:l=s,resolutionY:u=o}={}){super("LuminancePass"),this.fullscreenMaterial=new ps(r,t),this.needsSwap=!1,this.renderTarget=e,this.renderTarget===void 0&&(this.renderTarget=new Ge(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="LuminancePass.Target");const d=this.resolution=new et(this,l,u,a);d.addEventListener("change",m=>this.setSize(d.baseWidth,d.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}render(e,t,r,a,s){const o=this.fullscreenMaterial;o.inputBuffer=t.texture,e.setRenderTarget(this.renderToScreen?null:this.renderTarget),e.render(this.scene,this.camera)}setSize(e,t){const r=this.resolution;r.setBaseSize(e,t),this.renderTarget.setSize(r.width,r.height)}initialize(e,t,r){r!==void 0&&r!==ct&&(this.renderTarget.texture.type=r,this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}},er=class extends Er{constructor(e,t,{attributes:r=Je.NONE,blendFunction:a=X.NORMAL,defines:s=new Map,uniforms:o=new Map,extensions:l=null,vertexShader:u=null}={}){super(),this.name=e,this.renderer=null,this.attributes=r,this.fragmentShader=t,this.vertexShader=u,this.defines=s,this.uniforms=o,this.extensions=l,this.blendMode=new hs(a),this.blendMode.addEventListener("change",d=>this.setChanged()),this._inputColorSpace=Pt,this._outputColorSpace=an}get inputColorSpace(){return this._inputColorSpace}set inputColorSpace(e){this._inputColorSpace=e,this.setChanged()}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e,this.setChanged()}set mainScene(e){}set mainCamera(e){}getName(){return this.name}setRenderer(e){this.renderer=e}getDefines(){return this.defines}getUniforms(){return this.uniforms}getExtensions(){return this.extensions}getBlendMode(){return this.blendMode}getAttributes(){return this.attributes}setAttributes(e){this.attributes=e,this.setChanged()}getFragmentShader(){return this.fragmentShader}setFragmentShader(e){this.fragmentShader=e,this.setChanged()}getVertexShader(){return this.vertexShader}setVertexShader(e){this.vertexShader=e,this.setChanged()}setChanged(){this.dispatchEvent({type:"change"})}setDepthTexture(e,t=Et){}update(e,t,r){}setSize(e,t){}initialize(e,t,r){}dispose(){for(const e of Object.keys(this)){const t=this[e];(t instanceof Ge||t instanceof on||t instanceof ot||t instanceof De)&&this[e].dispose()}}},Tn=class extends De{constructor(e,t,r=null){super("RenderPass",e,t),this.needsSwap=!1,this.clearPass=new wn,this.overrideMaterialManager=r===null?null:new Hr(r),this.ignoreBackground=!1,this.skipShadowMapUpdate=!1,this.selection=null}set mainScene(e){this.scene=e}set mainCamera(e){this.camera=e}get renderToScreen(){return super.renderToScreen}set renderToScreen(e){super.renderToScreen=e,this.clearPass.renderToScreen=e}get overrideMaterial(){const e=this.overrideMaterialManager;return e!==null?e.material:null}set overrideMaterial(e){const t=this.overrideMaterialManager;e!==null?t!==null?t.setMaterial(e):this.overrideMaterialManager=new Hr(e):t!==null&&(t.dispose(),this.overrideMaterialManager=null)}getOverrideMaterial(){return this.overrideMaterial}setOverrideMaterial(e){this.overrideMaterial=e}get clear(){return this.clearPass.enabled}set clear(e){this.clearPass.enabled=e}getSelection(){return this.selection}setSelection(e){this.selection=e}isBackgroundDisabled(){return this.ignoreBackground}setBackgroundDisabled(e){this.ignoreBackground=e}isShadowMapDisabled(){return this.skipShadowMapUpdate}setShadowMapDisabled(e){this.skipShadowMapUpdate=e}getClearPass(){return this.clearPass}render(e,t,r,a,s){const o=this.scene,l=this.camera,u=this.selection,d=l.layers.mask,m=o.background,v=e.shadowMap.autoUpdate,E=this.renderToScreen?null:t;u!==null&&l.layers.set(u.getLayer()),this.skipShadowMapUpdate&&(e.shadowMap.autoUpdate=!1),(this.ignoreBackground||this.clearPass.overrideClearColor!==null)&&(o.background=null),this.clearPass.enabled&&this.clearPass.render(e,t),e.setRenderTarget(E),this.overrideMaterialManager!==null?this.overrideMaterialManager.render(e,o,l):e.render(o,l),l.layers.mask=d,o.background=m,e.shadowMap.autoUpdate=v}},Ce={LINEAR:0,REINHARD:1,REINHARD2:2,REINHARD2_ADAPTIVE:3,UNCHARTED2:4,OPTIMIZED_CINEON:5,CINEON:5,ACES_FILMIC:6,AGX:7,NEUTRAL:8},At={DEFAULT:0,ESKIL:1},vs=`#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
#ifdef DOWNSAMPLE_NORMALS
uniform lowp sampler2D normalBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);
#ifdef DOWNSAMPLE_NORMALS
vec3 n[4];n[0]=texture2D(normalBuffer,vUv0).rgb;n[1]=texture2D(normalBuffer,vUv1).rgb;n[2]=texture2D(normalBuffer,vUv2).rgb;n[3]=texture2D(normalBuffer,vUv3).rgb;
#else
vec3 n[4];n[0]=vec3(0.0);n[1]=vec3(0.0);n[2]=vec3(0.0);n[3]=vec3(0.0);
#endif
gl_FragColor=vec4(n[index],d[index]);}`,gs="uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}",Es=class extends tt{constructor(){super({name:"DepthDownsamplingMaterial",defines:{DEPTH_PACKING:"0"},uniforms:{depthBuffer:new re(null),normalBuffer:new re(null),texelSize:new re(new Ie)},blending:gt,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:vs,vertexShader:gs})}set depthBuffer(e){this.uniforms.depthBuffer.value=e}set depthPacking(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}setDepthBuffer(e,t=Et){this.depthBuffer=e,this.depthPacking=t}set normalBuffer(e){this.uniforms.normalBuffer.value=e,e!==null?this.defines.DOWNSAMPLE_NORMALS="1":delete this.defines.DOWNSAMPLE_NORMALS,this.needsUpdate=!0}setNormalBuffer(e){this.normalBuffer=e}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t)}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}},Ss=class extends De{constructor({normalBuffer:e=null,resolutionScale:t=.5,width:r=et.AUTO_SIZE,height:a=et.AUTO_SIZE,resolutionX:s=r,resolutionY:o=a}={}){super("DepthDownsamplingPass");const l=new Es;l.normalBuffer=e,this.fullscreenMaterial=l,this.needsDepthTexture=!0,this.needsSwap=!1,this.renderTarget=new Ge(1,1,{minFilter:vt,magFilter:vt,depthBuffer:!1,type:je}),this.renderTarget.texture.name="DepthDownsamplingPass.Target",this.renderTarget.texture.generateMipmaps=!1;const u=this.resolution=new et(this,s,o,t);u.addEventListener("change",d=>this.setSize(u.baseWidth,u.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}setDepthTexture(e,t=Et){this.fullscreenMaterial.depthBuffer=e,this.fullscreenMaterial.depthPacking=t}render(e,t,r,a,s){e.setRenderTarget(this.renderToScreen?null:this.renderTarget),e.render(this.scene,this.camera)}setSize(e,t){const r=this.resolution;r.setBaseSize(e,t),this.renderTarget.setSize(r.width,r.height),this.fullscreenMaterial.setSize(e,t)}initialize(e,t,r){const a=e.getContext();if(!(a.getExtension("EXT_color_buffer_float")||a.getExtension("EXT_color_buffer_half_float")))throw new Error("Rendering to float texture is not supported.")}},xs=`#include <packing>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
uniform lowp sampler2D luminanceBuffer0;uniform lowp sampler2D luminanceBuffer1;uniform float minLuminance;uniform float deltaTime;uniform float tau;varying vec2 vUv;void main(){float l0=unpackRGBAToFloat(texture2D(luminanceBuffer0,vUv));
#if __VERSION__ < 300
float l1=texture2DLodEXT(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;
#else
float l1=textureLod(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;
#endif
l0=max(minLuminance,l0);l1=max(minLuminance,l1);float adaptedLum=l0+(l1-l0)*(1.0-exp(-deltaTime*tau));gl_FragColor=(adaptedLum==1.0)?vec4(1.0):packFloatToRGBA(adaptedLum);}`,_s=class extends tt{constructor(){super({name:"AdaptiveLuminanceMaterial",defines:{MIP_LEVEL_1X1:"0.0"},uniforms:{luminanceBuffer0:new re(null),luminanceBuffer1:new re(null),minLuminance:new re(.01),deltaTime:new re(0),tau:new re(1)},extensions:{shaderTextureLOD:!0},blending:gt,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:xs,vertexShader:Cr})}set luminanceBuffer0(e){this.uniforms.luminanceBuffer0.value=e}setLuminanceBuffer0(e){this.uniforms.luminanceBuffer0.value=e}set luminanceBuffer1(e){this.uniforms.luminanceBuffer1.value=e}setLuminanceBuffer1(e){this.uniforms.luminanceBuffer1.value=e}set mipLevel1x1(e){this.defines.MIP_LEVEL_1X1=e.toFixed(1),this.needsUpdate=!0}setMipLevel1x1(e){this.mipLevel1x1=e}set deltaTime(e){this.uniforms.deltaTime.value=e}setDeltaTime(e){this.uniforms.deltaTime.value=e}get minLuminance(){return this.uniforms.minLuminance.value}set minLuminance(e){this.uniforms.minLuminance.value=e}getMinLuminance(){return this.uniforms.minLuminance.value}setMinLuminance(e){this.uniforms.minLuminance.value=e}get adaptationRate(){return this.uniforms.tau.value}set adaptationRate(e){this.uniforms.tau.value=e}getAdaptationRate(){return this.uniforms.tau.value}setAdaptationRate(e){this.uniforms.tau.value=e}},ws=class extends De{constructor(e,{minLuminance:t=.01,adaptationRate:r=1}={}){super("AdaptiveLuminancePass"),this.fullscreenMaterial=new _s,this.needsSwap=!1,this.renderTargetPrevious=new Ge(1,1,{minFilter:vt,magFilter:vt,depthBuffer:!1}),this.renderTargetPrevious.texture.name="Luminance.Previous";const a=this.fullscreenMaterial;a.luminanceBuffer0=this.renderTargetPrevious.texture,a.luminanceBuffer1=e,a.minLuminance=t,a.adaptationRate=r,this.renderTargetAdapted=this.renderTargetPrevious.clone(),this.renderTargetAdapted.texture.name="Luminance.Adapted",this.copyPass=new _n(this.renderTargetPrevious,!1)}get texture(){return this.renderTargetAdapted.texture}getTexture(){return this.renderTargetAdapted.texture}set mipLevel1x1(e){this.fullscreenMaterial.mipLevel1x1=e}get adaptationRate(){return this.fullscreenMaterial.adaptationRate}set adaptationRate(e){this.fullscreenMaterial.adaptationRate=e}render(e,t,r,a,s){this.fullscreenMaterial.deltaTime=a,e.setRenderTarget(this.renderToScreen?null:this.renderTargetAdapted),e.render(this.scene,this.camera),this.copyPass.render(e,this.renderTargetAdapted)}},Ts=`#include <tonemapping_pars_fragment>
uniform float whitePoint;
#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3
uniform float middleGrey;
#if TONE_MAPPING_MODE == 3
uniform lowp sampler2D luminanceBuffer;
#else
uniform float averageLuminance;
#endif
vec3 Reinhard2ToneMapping(vec3 color){color*=toneMappingExposure;float l=luminance(color);
#if TONE_MAPPING_MODE == 3
float lumAvg=unpackRGBAToFloat(texture2D(luminanceBuffer,vec2(0.5)));
#else
float lumAvg=averageLuminance;
#endif
float lumScaled=(l*middleGrey)/max(lumAvg,1e-6);float lumCompressed=lumScaled*(1.0+lumScaled/(whitePoint*whitePoint));lumCompressed/=(1.0+lumScaled);return clamp(lumCompressed*color,0.0,1.0);}
#elif TONE_MAPPING_MODE == 4
#define A 0.15
#define B 0.50
#define C 0.10
#define D 0.20
#define E 0.02
#define F 0.30
vec3 Uncharted2Helper(const in vec3 x){return((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}vec3 Uncharted2ToneMapping(vec3 color){color*=toneMappingExposure;return clamp(Uncharted2Helper(color)/Uncharted2Helper(vec3(whitePoint)),0.0,1.0);}
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){
#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3
outputColor=vec4(Reinhard2ToneMapping(inputColor.rgb),inputColor.a);
#elif TONE_MAPPING_MODE == 4
outputColor=vec4(Uncharted2ToneMapping(inputColor.rgb),inputColor.a);
#else
outputColor=vec4(toneMapping(inputColor.rgb),inputColor.a);
#endif
}`,Ms=class extends er{constructor({blendFunction:e=X.SRC,adaptive:t=!1,mode:r=t?Ce.REINHARD2_ADAPTIVE:Ce.AGX,resolution:a=256,maxLuminance:s=4,whitePoint:o=s,middleGrey:l=.6,minLuminance:u=.01,averageLuminance:d=1,adaptationRate:m=1}={}){super("ToneMappingEffect",Ts,{blendFunction:e,uniforms:new Map([["luminanceBuffer",new re(null)],["maxLuminance",new re(s)],["whitePoint",new re(o)],["middleGrey",new re(l)],["averageLuminance",new re(d)]])}),this.renderTargetLuminance=new Ge(1,1,{minFilter:fi,depthBuffer:!1}),this.renderTargetLuminance.texture.generateMipmaps=!0,this.renderTargetLuminance.texture.name="Luminance",this.luminancePass=new ms({renderTarget:this.renderTargetLuminance}),this.adaptiveLuminancePass=new ws(this.luminancePass.texture,{minLuminance:u,adaptationRate:m}),this.uniforms.get("luminanceBuffer").value=this.adaptiveLuminancePass.texture,this.resolution=a,this.mode=r}get mode(){return Number(this.defines.get("TONE_MAPPING_MODE"))}set mode(e){if(this.mode===e)return;const r=Sr.replace(/\D+/g,"")>=168?"CineonToneMapping(texel)":"OptimizedCineonToneMapping(texel)";switch(this.defines.clear(),this.defines.set("TONE_MAPPING_MODE",e.toFixed(0)),e){case Ce.LINEAR:this.defines.set("toneMapping(texel)","LinearToneMapping(texel)");break;case Ce.REINHARD:this.defines.set("toneMapping(texel)","ReinhardToneMapping(texel)");break;case Ce.CINEON:case Ce.OPTIMIZED_CINEON:this.defines.set("toneMapping(texel)",r);break;case Ce.ACES_FILMIC:this.defines.set("toneMapping(texel)","ACESFilmicToneMapping(texel)");break;case Ce.AGX:this.defines.set("toneMapping(texel)","AgXToneMapping(texel)");break;case Ce.NEUTRAL:this.defines.set("toneMapping(texel)","NeutralToneMapping(texel)");break;default:this.defines.set("toneMapping(texel)","texel");break}this.adaptiveLuminancePass.enabled=e===Ce.REINHARD2_ADAPTIVE,this.setChanged()}getMode(){return this.mode}setMode(e){this.mode=e}get whitePoint(){return this.uniforms.get("whitePoint").value}set whitePoint(e){this.uniforms.get("whitePoint").value=e}get middleGrey(){return this.uniforms.get("middleGrey").value}set middleGrey(e){this.uniforms.get("middleGrey").value=e}get averageLuminance(){return this.uniforms.get("averageLuminance").value}set averageLuminance(e){this.uniforms.get("averageLuminance").value=e}get adaptiveLuminanceMaterial(){return this.adaptiveLuminancePass.fullscreenMaterial}getAdaptiveLuminanceMaterial(){return this.adaptiveLuminanceMaterial}get resolution(){return this.luminancePass.resolution.width}set resolution(e){const t=Math.max(0,Math.ceil(Math.log2(e))),r=Math.pow(2,t);this.luminancePass.resolution.setPreferredSize(r,r),this.adaptiveLuminanceMaterial.mipLevel1x1=t}getResolution(){return this.resolution}setResolution(e){this.resolution=e}get adaptive(){return this.mode===Ce.REINHARD2_ADAPTIVE}set adaptive(e){this.mode=e?Ce.REINHARD2_ADAPTIVE:Ce.REINHARD2}get adaptationRate(){return this.adaptiveLuminanceMaterial.adaptationRate}set adaptationRate(e){this.adaptiveLuminanceMaterial.adaptationRate=e}get distinction(){return console.warn(this.name,"distinction was removed."),1}set distinction(e){console.warn(this.name,"distinction was removed.")}update(e,t,r){this.adaptiveLuminancePass.enabled&&(this.luminancePass.render(e,t),this.adaptiveLuminancePass.render(e,null,null,r))}initialize(e,t,r){this.adaptiveLuminancePass.initialize(e,t,r)}},ys=`uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;
#if VIGNETTE_TECHNIQUE == 0
float d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));
#else
vec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));
#endif
outputColor=vec4(color,inputColor.a);}`,Vs=class extends er{constructor({blendFunction:e,eskil:t=!1,technique:r=t?At.ESKIL:At.DEFAULT,offset:a=.5,darkness:s=.5}={}){super("VignetteEffect",ys,{blendFunction:e,defines:new Map([["VIGNETTE_TECHNIQUE",r.toFixed(0)]]),uniforms:new Map([["offset",new re(a)],["darkness",new re(s)]])})}get technique(){return Number(this.defines.get("VIGNETTE_TECHNIQUE"))}set technique(e){this.technique!==e&&(this.defines.set("VIGNETTE_TECHNIQUE",e.toFixed(0)),this.setChanged())}get eskil(){return this.technique===At.ESKIL}set eskil(e){this.technique=e?At.ESKIL:At.DEFAULT}getTechnique(){return this.technique}setTechnique(e){this.technique=e}get offset(){return this.uniforms.get("offset").value}set offset(e){this.uniforms.get("offset").value=e}getOffset(){return this.offset}setOffset(e){this.offset=e}get darkness(){return this.uniforms.get("darkness").value}set darkness(e){this.uniforms.get("darkness").value=e}getDarkness(){return this.darkness}setDarkness(e){this.darkness=e}},Rs=`#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
}`,bs="uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}",Cs=class extends tt{constructor(e,t,r,a,s=!1){super({name:"EffectMaterial",defines:{THREE_REVISION:Sr.replace(/\D+/g,""),DEPTH_PACKING:"0",ENCODE_OUTPUT:"1"},uniforms:{inputBuffer:new re(null),depthBuffer:new re(null),resolution:new re(new Ie),texelSize:new re(new Ie),cameraNear:new re(.3),cameraFar:new re(1e3),aspect:new re(1),time:new re(0)},blending:gt,toneMapped:!1,depthWrite:!1,depthTest:!1,dithering:s}),e&&this.setShaderParts(e),t&&this.setDefines(t),r&&this.setUniforms(r),this.copyCameraSettings(a)}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}get depthBuffer(){return this.uniforms.depthBuffer.value}set depthBuffer(e){this.uniforms.depthBuffer.value=e}get depthPacking(){return Number(this.defines.DEPTH_PACKING)}set depthPacking(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}setDepthBuffer(e,t=Et){this.depthBuffer=e,this.depthPacking=t}setShaderData(e){this.setShaderParts(e.shaderParts),this.setDefines(e.defines),this.setUniforms(e.uniforms),this.setExtensions(e.extensions)}setShaderParts(e){return this.fragmentShader=Rs.replace(Q.FRAGMENT_HEAD,e.get(Q.FRAGMENT_HEAD)||"").replace(Q.FRAGMENT_MAIN_UV,e.get(Q.FRAGMENT_MAIN_UV)||"").replace(Q.FRAGMENT_MAIN_IMAGE,e.get(Q.FRAGMENT_MAIN_IMAGE)||""),this.vertexShader=bs.replace(Q.VERTEX_HEAD,e.get(Q.VERTEX_HEAD)||"").replace(Q.VERTEX_MAIN_SUPPORT,e.get(Q.VERTEX_MAIN_SUPPORT)||""),this.needsUpdate=!0,this}setDefines(e){for(const t of e.entries())this.defines[t[0]]=t[1];return this.needsUpdate=!0,this}setUniforms(e){for(const t of e.entries())this.uniforms[t[0]]=t[1];return this}setExtensions(e){this.extensions={};for(const t of e)this.extensions[t]=!0;return this}get encodeOutput(){return this.defines.ENCODE_OUTPUT!==void 0}set encodeOutput(e){this.encodeOutput!==e&&(e?this.defines.ENCODE_OUTPUT="1":delete this.defines.ENCODE_OUTPUT,this.needsUpdate=!0)}isOutputEncodingEnabled(e){return this.encodeOutput}setOutputEncodingEnabled(e){this.encodeOutput=e}get time(){return this.uniforms.time.value}set time(e){this.uniforms.time.value=e}setDeltaTime(e){this.uniforms.time.value+=e}adoptCameraSettings(e){this.copyCameraSettings(e)}copyCameraSettings(e){e&&(this.uniforms.cameraNear.value=e.near,this.uniforms.cameraFar.value=e.far,e instanceof gr?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}setSize(e,t){const r=this.uniforms;r.resolution.value.set(e,t),r.texelSize.value.set(1/e,1/t),r.aspect.value=e/t}static get Section(){return Q}};function Gr(e,t,r){for(const a of t){const s="$1"+e+a.charAt(0).toUpperCase()+a.slice(1),o=new RegExp("([^\\.])(\\b"+a+"\\b)","g");for(const l of r.entries())l[1]!==null&&r.set(l[0],l[1].replace(o,s))}}function Is(e,t,r){let a=t.getFragmentShader(),s=t.getVertexShader();const o=a!==void 0&&/mainImage/.test(a),l=a!==void 0&&/mainUv/.test(a);if(r.attributes|=t.getAttributes(),a===void 0)throw new Error(`Missing fragment shader (${t.name})`);if(l&&r.attributes&Je.CONVOLUTION)throw new Error(`Effects that transform UVs are incompatible with convolution effects (${t.name})`);if(!o&&!l)throw new Error(`Could not find mainImage or mainUv function (${t.name})`);{const u=/\w+\s+(\w+)\([\w\s,]*\)\s*{/g,d=r.shaderParts;let m=d.get(Q.FRAGMENT_HEAD)||"",v=d.get(Q.FRAGMENT_MAIN_UV)||"",E=d.get(Q.FRAGMENT_MAIN_IMAGE)||"",b=d.get(Q.VERTEX_HEAD)||"",B=d.get(Q.VERTEX_MAIN_SUPPORT)||"";const Z=new Set,Y=new Set;if(l&&(v+=`	${e}MainUv(UV);
`,r.uvTransformation=!0),s!==null&&/mainSupport/.test(s)){const P=/mainSupport *\([\w\s]*?uv\s*?\)/.test(s);B+=`	${e}MainSupport(`,B+=P?`vUv);
`:`);
`;for(const D of s.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))for(const K of D[1].split(/\s*,\s*/))r.varyings.add(K),Z.add(K),Y.add(K);for(const D of s.matchAll(u))Y.add(D[1])}for(const P of a.matchAll(u))Y.add(P[1]);for(const P of t.defines.keys())Y.add(P.replace(/\([\w\s,]*\)/g,""));for(const P of t.uniforms.keys())Y.add(P);Y.delete("while"),Y.delete("for"),Y.delete("if"),t.uniforms.forEach((P,D)=>r.uniforms.set(e+D.charAt(0).toUpperCase()+D.slice(1),P)),t.defines.forEach((P,D)=>r.defines.set(e+D.charAt(0).toUpperCase()+D.slice(1),P));const z=new Map([["fragment",a],["vertex",s]]);Gr(e,Y,r.defines),Gr(e,Y,z),a=z.get("fragment"),s=z.get("vertex");const G=t.blendMode;if(r.blendModes.set(G.blendFunction,G),o){t.inputColorSpace!==null&&t.inputColorSpace!==r.colorSpace&&(E+=t.inputColorSpace===$e?`color0 = sRGBTransferOETF(color0);
	`:`color0 = sRGBToLinear(color0);
	`),t.outputColorSpace!==an?r.colorSpace=t.outputColorSpace:t.inputColorSpace!==null&&(r.colorSpace=t.inputColorSpace);const P=/MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;E+=`${e}MainImage(color0, UV, `,r.attributes&Je.DEPTH&&P.test(a)&&(E+="depth, ",r.readDepth=!0),E+=`color1);
	`;const D=e+"BlendOpacity";r.uniforms.set(D,G.opacity),E+=`color0 = blend${G.blendFunction}(color0, color1, ${D});

	`,m+=`uniform float ${D};

`}if(m+=a+`
`,s!==null&&(b+=s+`
`),d.set(Q.FRAGMENT_HEAD,m),d.set(Q.FRAGMENT_MAIN_UV,v),d.set(Q.FRAGMENT_MAIN_IMAGE,E),d.set(Q.VERTEX_HEAD,b),d.set(Q.VERTEX_MAIN_SUPPORT,B),t.extensions!==null)for(const P of t.extensions)r.extensions.add(P)}}var As=class extends De{constructor(e,...t){super("EffectPass"),this.fullscreenMaterial=new Cs(null,null,null,e),this.listener=r=>this.handleEvent(r),this.effects=[],this.setEffects(t),this.skipRendering=!1,this.minTime=1,this.maxTime=Number.POSITIVE_INFINITY,this.timeScale=1}set mainScene(e){for(const t of this.effects)t.mainScene=e}set mainCamera(e){this.fullscreenMaterial.copyCameraSettings(e);for(const t of this.effects)t.mainCamera=e}get encodeOutput(){return this.fullscreenMaterial.encodeOutput}set encodeOutput(e){this.fullscreenMaterial.encodeOutput=e}get dithering(){return this.fullscreenMaterial.dithering}set dithering(e){const t=this.fullscreenMaterial;t.dithering=e,t.needsUpdate=!0}setEffects(e){for(const t of this.effects)t.removeEventListener("change",this.listener);this.effects=e.sort((t,r)=>r.attributes-t.attributes);for(const t of this.effects)t.addEventListener("change",this.listener)}updateMaterial(){const e=new Da;let t=0;for(const l of this.effects)if(l.blendMode.blendFunction===X.DST)e.attributes|=l.getAttributes()&Je.DEPTH;else{if(e.attributes&l.getAttributes()&Je.CONVOLUTION)throw new Error(`Convolution effects cannot be merged (${l.name})`);Is("e"+t++,l,e)}let r=e.shaderParts.get(Q.FRAGMENT_HEAD),a=e.shaderParts.get(Q.FRAGMENT_MAIN_IMAGE),s=e.shaderParts.get(Q.FRAGMENT_MAIN_UV);const o=/\bblend\b/g;for(const l of e.blendModes.values())r+=l.getShaderCode().replace(o,`blend${l.blendFunction}`)+`
`;e.attributes&Je.DEPTH?(e.readDepth&&(a=`float depth = readDepth(UV);

	`+a),this.needsDepthTexture=this.getDepthTexture()===null):this.needsDepthTexture=!1,e.colorSpace===$e&&(a+=`color0 = sRGBToLinear(color0);
	`),e.uvTransformation?(s=`vec2 transformedUv = vUv;
`+s,e.defines.set("UV","transformedUv")):e.defines.set("UV","vUv"),e.shaderParts.set(Q.FRAGMENT_HEAD,r),e.shaderParts.set(Q.FRAGMENT_MAIN_IMAGE,a),e.shaderParts.set(Q.FRAGMENT_MAIN_UV,s);for(const[l,u]of e.shaderParts)u!==null&&e.shaderParts.set(l,u.trim().replace(/^#/,`
#`));this.skipRendering=t===0,this.needsSwap=!this.skipRendering,this.fullscreenMaterial.setShaderData(e)}recompile(){this.updateMaterial()}getDepthTexture(){return this.fullscreenMaterial.depthBuffer}setDepthTexture(e,t=Et){this.fullscreenMaterial.depthBuffer=e,this.fullscreenMaterial.depthPacking=t;for(const r of this.effects)r.setDepthTexture(e,t)}render(e,t,r,a,s){for(const o of this.effects)o.update(e,t,a);if(!this.skipRendering||this.renderToScreen){const o=this.fullscreenMaterial;o.inputBuffer=t.texture,o.time+=a*this.timeScale,e.setRenderTarget(this.renderToScreen?null:r),e.render(this.scene,this.camera)}}setSize(e,t){this.fullscreenMaterial.setSize(e,t);for(const r of this.effects)r.setSize(e,t)}initialize(e,t,r){this.renderer=e;for(const a of this.effects)a.initialize(e,t,r);this.updateMaterial(),r!==void 0&&r!==ct&&(this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}dispose(){super.dispose();for(const e of this.effects)e.removeEventListener("change",this.listener),e.dispose()}handleEvent(e){switch(e.type){case"change":this.recompile();break}}},Bs=class extends De{constructor(e,t,{renderTarget:r,resolutionScale:a=1,width:s=et.AUTO_SIZE,height:o=et.AUTO_SIZE,resolutionX:l=s,resolutionY:u=o}={}){super("NormalPass"),this.needsSwap=!1,this.renderPass=new Tn(e,t,new ui);const d=this.renderPass;d.ignoreBackground=!0,d.skipShadowMapUpdate=!0;const m=d.getClearPass();m.overrideClearColor=new sn(7829503),m.overrideClearAlpha=1,this.renderTarget=r,this.renderTarget===void 0&&(this.renderTarget=new Ge(1,1,{minFilter:vt,magFilter:vt}),this.renderTarget.texture.name="NormalPass.Target");const v=this.resolution=new et(this,l,u,a);v.addEventListener("change",E=>this.setSize(v.baseWidth,v.baseHeight))}set mainScene(e){this.renderPass.mainScene=e}set mainCamera(e){this.renderPass.mainCamera=e}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}getResolutionScale(){return this.resolution.scale}setResolutionScale(e){this.resolution.scale=e}render(e,t,r,a,s){const o=this.renderToScreen?null:this.renderTarget;this.renderPass.render(e,o,o)}setSize(e,t){const r=this.resolution;r.setBaseSize(e,t),this.renderTarget.setSize(r.width,r.height)}};const Ds=R.createContext(null),Vr=e=>(e.getAttributes()&Je.CONVOLUTION)===Je.CONVOLUTION,Ws=Dt.memo(R.forwardRef(({children:e,camera:t,scene:r,resolutionScale:a,enabled:s=!0,renderPriority:o=1,autoClear:l=!0,depthBuffer:u,enableNormalPass:d,stencilBuffer:m,multisampling:v=8,frameBufferType:E=Be},b)=>{const{gl:B,scene:Z,camera:Y,size:z}=ze(),G=r||Z,P=t||Y,[D,K,V]=R.useMemo(()=>{const _=Gi(),S=new Ba(B,{depthBuffer:u,stencilBuffer:m,multisampling:v>0&&_?v:0,frameBufferType:E});S.addPass(new Tn(G,P));let U=null,A=null;return d&&(A=new Bs(G,P),A.enabled=!1,S.addPass(A),a!==void 0&&_&&(U=new Ss({normalBuffer:A.texture,resolutionScale:a}),U.enabled=!1,S.addPass(U))),[S,A,U]},[P,B,u,m,v,E,G,d,a]);R.useEffect(()=>D==null?void 0:D.setSize(z.width,z.height),[D,z]),mr((_,S)=>{if(s){const U=B.autoClear;B.autoClear=l,m&&!l&&B.clearStencil(),D.render(S),B.autoClear=U}},s?o:0);const L=R.useRef(null);R.useLayoutEffect(()=>{var _;const S=[],U=(_=L.current)==null?void 0:_.__r3f;if(U&&D){const A=U.objects;for(let k=0;k<A.length;k++){const $=A[k];if($ instanceof er){const O=[$];if(!Vr($)){let F=null;for(;(F=A[k+1])instanceof er&&!Vr(F);)O.push(F),k++}const W=new As(P,...O);S.push(W)}else $ instanceof De&&S.push($)}for(const k of S)D==null||D.addPass(k);K&&(K.enabled=!0),V&&(V.enabled=!0)}return()=>{for(const A of S)D==null||D.removePass(A);K&&(K.enabled=!1),V&&(V.enabled=!1)}},[D,e,P,K,V]),R.useEffect(()=>{const _=B.toneMapping;return B.toneMapping=mi,()=>{B.toneMapping=_}},[B]);const ne=R.useMemo(()=>({composer:D,normalPass:K,downSamplingPass:V,resolutionScale:a,camera:P,scene:G}),[D,K,V,a,P,G]);return R.useImperativeHandle(b,()=>D,[D]),Ae.jsx(Ds.Provider,{value:ne,children:Ae.jsx("group",{ref:L,children:e})})}));let Ns=0;const Wr=new WeakMap,Ps=(e,t)=>Dt.forwardRef(function({blendFunction:a=void 0,opacity:s=void 0,...o},l){let u=Wr.get(e);if(!u){const v=`@react-three/postprocessing/${e.name}-${Ns++}`;nn({[v]:e}),Wr.set(e,u=v)}const d=ze(v=>v.camera),m=Dt.useMemo(()=>{var v,E;return[...(v=void 0)!=null?v:[],...(E=o.args)!=null?E:[{...t,...o}]]},[JSON.stringify(o)]);return Ae.jsx(u,{camera:d,"blendMode-blendFunction":a,"blendMode-opacity-value":s,...o,ref:l,args:m})}),Zs=Ps(Ms),Mn=R.createContext(void 0),$s=({initialPoi:e,children:t})=>{const[r,a]=R.useState(e),[s,o]=R.useState(null),l=u=>{o(r),a(u)};return Ae.jsx(Mn.Provider,{value:{activePoi:r,previousPoi:s,setActivePoi:l},children:t})},js=()=>{const e=R.useContext(Mn);if(!e)throw new Error("usePOI must be used within a POIProvider");return e},Xs=()=>{const{progress:e}=Hi();return Ae.jsx(Li,{center:!0,children:Ae.jsxs(Vn,{display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",children:[Ae.jsx(vi,{size:80,thickness:4}),Ae.jsxs(Wn,{variant:"h6",color:"textPrimary",mt:2,children:[Math.round(e),"% Loaded"]})]})})},Ys=({modelData:e})=>Ae.jsx("group",{dispose:null,children:e.map((t,r)=>Ae.jsx(Os,{...t},r))});function Os(e){const t=Zn+e.path,{scene:r}=gi(t),a=R.useMemo(()=>{const s=new Ei;return s.position.copy(r.position),s.rotation.copy(r.rotation),s.scale.copy(r.scale),r.position.set(0,0,0),r.rotation.set(0,0,0),r.scale.set(1,1,1),s.add(r),s},[r]);return R.useEffect(()=>{r.traverse(s=>{s.isMesh&&(s.castShadow=!0,s.receiveShadow=!0)})},[r]),Ae.jsx("primitive",{object:a,dispose:null})}const Ks=({cameraSettings:e,debugSettings:t})=>{const{scene:r}=ze();let a=r.getObjectByName("cameraFocusObject");if(!a){if(a=new Si,a.name="cameraFocusObject",e!=null&&e.lookAt&&a.position.set(e.lookAt.x,e.lookAt.y,e.lookAt.z),t!=null&&t.allTrue){const s=new xi(.05,32,32),o=new rn({color:16711680}),l=new Lt(s,o);a.add(l)}r.add(a)}return null};export{Ks as A,Us as C,Hs as E,Xs as L,$s as P,ks as S,Zs as T,Vs as V,Ws as a,zs as b,Ys as c,De as d,js as u,Ps as w};
